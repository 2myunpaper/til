## 트리

비선형 구조.

원소들 간에 1:n 관계를 가지는 자료구조. 원소들 간에 계층 관계를 가지는 계층형 자료구조

상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조를 뜻한다.

아래에 있는 예시 트리를 이용하여 관련 용어를 익혀보자.

<aside>

*ex) 트리 T1*

A                                       ——  Level 0

[B C D]                             ——  Level 1

[E F] [G] [H I J]                ——  Level 2

[_] [K] [_] [_] [_] [_]          ——  Level 3

*※ 레벨은 참고로 상대적인 것으로, 1부터 시작될 수도 있다.*

</aside>

### 트리 관련 용어

- 각 점들은 **정점(node, vertex)**이라고 부른다.
    
    → A, B, C, D, E, F, G, H, I, J, K는 트리의 **노드(node)**이다.
    
- 노드를 연결하는 선(부모 노드와 자식 노드를 연결하는 선)을 **간선(edge)**라고 부른다.
- 트리의 시작 노드를 **루트 노드(root node)** 라고 부른다.
    
    →  A는 트리의 **루트 노드**이다.
    
- 같은 부모 노드의 자식 노드들을 **형제 노드(sibling node)**라고 한다.
    
    → B,C,D는 A의 자식 노드들이므로, **형제 노드**이다.
    
- 간선(edge)를 따라 루트 노드까지 이르는 경로에 있는 모든 노드들을 **조상 노드**라고 한다.
    
    → K의 **조상 노드**는 F, B, A 이다.
    
- 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리를 **서브 트리(subtree)**라고 한다.
- 서브 트리에 있는 하위 레벨의 노드들을 **자손 노드**라고 한다.
    
    → B의 **자손 노드**는 E, F, K이다.
    

### 차수 (degree)

- **노드의 차수**는 노드에 연결된 자식 노드의 수를 뜻한다.
    
    → B의 차수는 2, C의 차수는 1이다.
    
- **트리의 차수**는 트리에 있는 노드의 차수 중에서 가장 큰 값을 뜻한다.
    
    → **트리 T1의 차수**는 3이다.
    
- 차수가 0인 노드 즉, 자식 노드가 없는 노드를 **단말 노드(리프 노드)**라고 한다.
    
    → E, K, G, H, I J를 **단말 노드** 또는 **잎(leaf)** 노드라고 부른다.
    

### 높이

- 루트에서 노드에 이르는 간선의 수, 노드의 레벨을 **노드의 높이**라고 한다.
    
    → B의 **높이**는 1, F의 **높이**는 2이다.
    
- 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨을 **트리의 높이**라고 한다.
    
    → **트리 T1의 높이**는 3이다.
    

## 이진 트리

모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리.

각 노드가 자식 노드를 **최대한 2개 까지**만 가질 수 있는 트리.

- 왼쪽 자식 노드(left child node), 오른쪽 자식 노드(right child node)
- 레벨 i에서의 노드의 최대 개수는 **2^i개**
- 높이가 h인 이진 트리가 가질 수 있는 노드의 **최소 개수는 (h+1)개**가 되며, **최대 개수는 (2^(h+1)-1)개**가 된다.

### 포화 이진 트리(Full Binary Tree)

모든 레벨에 노드가 포화상태로 차 있는 이진 트리

- 높이가 h일 때, 최대 노드의 개수인 (2^(h+1)-1) 노드를 가진 이진 트리
    
    → 높이가 3이면, 2^(3+1)-1 = 15개의 노드를 가진다.
    
- 루트를 1번으로 하여 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가진다.

<aside>

*ex) 포화 이진 트리 T2*

1

[2 3]

[4 5] [6 7]

[8 9] [10 11] [12 13] [14 15]

…

</aside>

### 완전 이진 트리(Complete Binary Tree)

높이가 h이고 노드 수가 n개(2^h ≤ n ≤ 2^(h+1)-1)일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

→ 노드가 10개이고, 1번부터 10번까지 노드가 순서대로 채워져 있으면 완전 이진 트리이다.

### 편향 이진 트리(Skewed Binary Tree)

높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

→ 왼쪽 편향 이진 트리, 오른쪽 편향 이진 트리

## 순회

트리의 각 노드를 중복되지 않게 전부 방문(visit) 하는 것을 말하는데 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다. 따라서 특별한 방법이 필요하다.

<aside>

**순회(traversal)**

트리의 노드들을 체계적으로 방문하는 것

</aside>

루트를 **V**, 왼쪽 서브트리를 **L**, 오른쪽 서브트리를 **R**이라고 하자.

순회 방법에는 3가지가 있다.

- **전위 순회(preorder traversal)** : VLR
    
    부모 노드를 방문한 후, 자식노드를 좌,우 순서로 방문한다.
    
- **중위 순회(inorder traversal)** : LVR
    
    왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.
    
- **후위 순회(postorder traversal)** : LRV
    
    자식노드를 좌우 순서로 방문한 후, 부모노드로 방문한다.
    

### 전위 순회(preorder traversal)

1. 현재 노드 n을 방문하여 처리한다 → V
2. 현재 노드 n의 왼쪽 서브 트리로 이동한다 → L
3. 현재 노드 n의 오른쪽 서브 트리로 이동한다 → R

```python
def preorder_traverse(T):  # 전위순회
	if T:           # T is not None
		visit(T)      # print(T.item)
		preorder_traverse(T.left)
		preorder_traverse(T.right)
```

<aside>

*ex) 전위 순회 T3*

A

[B C]

[D E] [F G]

[_] [H I] [_] [_]

순서 1 : A → A_leftchild → A_rightchild

순서 2 : A → B D B_rightchild → C F G

total : **A B D E H I C F G**

</aside>

*※ 순회는 반드시 root에서 시작하지 않아도 된다! 단, 순회를 하게 될 경우 순회 시작 지점에서 부모 노드로 거슬러 올라가서 순회하지는 않는다.*

### 중위 순회(inorder traversal)

1. 현재 노드 n의 왼쪽 서브 트리로 이동한다 → L
2. 현재 노드 n을 방문하여 처리한다 → V
3. 현재 노드 n의 오른쪽 서브 트리로 이동한다 → R

```python
def inorder_traverse(T):  # 중위순회
	if T:          # T is not None
		inorder_traverse(T.left)
		visit(T)     # print(T.item)
		inorder_traverse(T.right)
```

<aside>

*ex) 전위 순회 T4*

A

[B C]

[D E] [F G]

[_] [H I] [_] [_]

순서 1 : A_leftchild → A → A_rightchild

순서 2 : D B B_rightchild → A → F C G

total : **D B H E I A F C G**

</aside>

### 후위 순회(postorder traversal)

1. 현재 노드 n의 왼쪽 서브 트리로 이동한다 → L
2. 현재 노드 n의 오른쪽 서브 트리로 이동한다 → R
3. 현재 노드 n을 방문하여 처리한다 → V

```python
def postorder_traverse(T):  # 후위순회
	if T:          # T is not None
		inorder_traverse(T.left)
		inorder_traverse(T.right)
		visit(T)     # print(T.item)
```

<aside>

*ex) 전위 순회 T5*

A

[B C]

[D E] [F G]

[_] [H I] [_] [_]

순서 1 : A_leftchild → A_rightchild → A

순서 2 : D B_rightchild B → F G C → A

total : **D H I E B F G C A**

</aside>

위에 배운 전위, 중위, 후위 순회를 이용하여

아래 예제를 풀어보자.

<aside>

*ex)  순회 예제 T*

A

[B C]

[D E] [F G]

[H I] [J _] [_ K] [L M]

- **전위 순회 (VLR)**
    
    A → A_lc → A_rc
    
    A → B B_lc B_rc → C C_lc C_rc
    
    **A B D H I E J C F K G L M**
    
- **중위 순회 (LVR)**
    
    A_lc → A → A_rc
    
    B_lc B B_rc → A → C_lc C C_rc
    
    **H D I B J E A F K C L G M**
    
- **후위 순회 (LRV)**
    
    A_lc → A_rc → A
    
    B_lc B_rc B → C_lc C_rc C → A
    
    **H I D J E B K F L M G C A**
    
</aside>

## 이진 트리 표현

### 배열을 이용한 이진 트리의 표현

이진 트리에 각 노드 번호를 부여한다.

**루트의 번호를 1**로 하고, 레벨 n에 있는 노드에 대하여 **왼쪽부터 오른쪽**으로 2^n 부터 2^(n+1)-1 까지 번호를 차례로 부여한다.

→ **포화 이진 트리, 완전 이진 트리**에 적합하다.

- 노드 번호가 i인 노드의 부모 노드 번호 : **i/2**
- 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 : **2*i**
- 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 : **2*i + 1**
- 레벨 n의 노드 번호 시작 번호 : **2^n**
    
    → 5번 노드의 부모 인덱스는 5/2 = 2,
    
    → 5번 노드의 왼쪽 자식 노드의 인덱스는 5*2 = 10,
    
    → 5번 노드의 오른쪽 자식 노드의 인덱스는 5*2 + 1 = 11
    

노드 번호를 배열의 인덱스로 사용한다.

높이가 h인 이진 트리를 위한 배열의 크기는?

→ 레벨 i의 최대 노드 수는 2^i개

→ 따라서 배열의 크기는 **2^(h+1) -1** 만큼 필요하다.

하지만,

배열을 이용한 이진 트리 표현 방법은 **편향 이진 트리에 매우 불리하게 작용**한다.

→ 배열 메모리 낭비가 심해진다.

그리고 트리의 중간에 새로운 노드를 삽입하거나, 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워진다.

### 참고 : 이진 트리의 저장

간선의 개수를 입력 받고, 간선의 개수만큼 부모 자식 순 세트로 입력 받는다.

예를 들어 아래와 같이 입력 받았다고 가정한다.

<aside>

간선의 개수 : 4

입력 받은 관계 : 1 2 1 3 3 4 3 5

</aside>

입력 받은 것을 저장하는 방법은 아래와 같이 적용해볼 수 있다.

- **부모 번호를 인덱스로 자식 번호를 저장**
    
    
    | **부모 (p)** | **자식1 (c1)** | **자식2 (c2)** |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 1 | 2 | 3 |
    | 2 | 0 | 0 |
    | 3 | 4 | 5 |
    | 4 | 0 | 0 |
    | 5 | 0 | 0 |
- **자식 번호를 인덱스로 부모 번호를 저장**
    
    
    | **자식 (c)** | **부모(par)** |
    | --- | --- |
    | 0 | 0 |
    | 1 | 0 |
    | 2 | 1 |
    | 3 | 1 |
    | 4 | 3 |
    | 5 | 3 |

이를 이용하여 루트 찾기, 조상 찾기가 가능해진다.

```python
# 5번 노드의 조상 및 루트 찾기
c = 5
while (a[c] != 0):  # 루트인지 확인
	c = a[c]
	anc.append(c)     # 조상 목록
root = c
```

### 참고 : 수식 트리

수식을 표현하는 이진 트리. 수식 이진 트리(Expression Binary Tree)라고 부르기도 한다.

**연산자는 루트 노드이거나 가지 노드**이며, **피연산자는 모두 잎 노드**이다.

<aside>

ex) A / B * C * D + E

중위 순회 (LVR) : A / B * C * D + E (식의 중위 표기법)

후위 순회 (LRV) : A B / C * D * E + (식의 후위 표기법)

전위 순회 (VLR) : + * * / A B C D E (식의 전위 표기법)

</aside>