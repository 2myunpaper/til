## 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

컴퓨터에 분야에서 알고리즘을 표현하는 방법은 크게 두 가지가 있다.

**의사 코드, 순서도**

좋은 알고리즘은 **정확성, 작업량, 메모리 사용량, 단순성, 최적성**을 고려한다.

많은 무제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

*ex)* 1부터 100까지 합을 구하는 문제

알고리즘1 : 100번의 연산 (1부터 순서대로 100까지 더함)

알고리즘2 : 100*(1+100)/2 = 5050 → 3번의 연산(덧셈 1번, 곱셈 1번, 나눗셈 1번)만 필요함.

알고리즘2가 알고리즘1보다 작업량이 적다.

이러한 작업량을 표현할 때 시간복잡도로 표현한다.

<aside>

**시간 복잡도 (Time Complexity)**

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산
</aside>

그러면 위의 예시는 다음과 같이 표현할 수 있겠다.

| **알고리즘 1** | **알고리즘 2** |
| --- | --- |
| 1 + n*2 = 2n + 1 | 3번의 연산 |

작업량을 보면 알고리즘1이 더 많은 것을 확인할 수 있다.

### 시간 복잡도 (빅-오 (O) 표기법)

시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하는 기법이다.

계수는 생략해서 표현한다.

*ex)*

O(3n + 2) = O(3n) = O(n)

O(4) = O(1)

O(2n^2 + 10n + 100) = O(n^2)

ex) n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간 복잡도는? → O(n)

요소 수가 증가함에 따가 각기 다른 시간복잡도의 알고리즘의 연산 수도 달라진다.

*ex)* N, logN, N, NlogN, N^2, N^3 …

## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

*ex)* num = [0,1,2,3,4,5]

프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.

배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.

단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

### 1차원 배열의 선언

arr = [1, 2, 3]

→ arr는 [1, 2, 3]을 가리키는 변수임.

→ 배열은 각 자리마다 인덱스 번호가 있다.

### 배열 연산

```python
# 첫 줄에 양수의 개수 N이 주어진다. (5 <= N <= 1000)
# 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어진다. (1 <= Ai <= 1000000)

N = int(input())  # 입력예 : 6
arr = list(map(int, input().split()))  # 입력예 : 2 7 5 3 1 4

# 배열원소의 합 s 구하기
s = 0
for i in range(N):  # 모든 원소에 대해
    s += arr[i]

print(s)

# 배열 원소 중 최댓값 max_v 찾기
max_v = arr[0]
for i in range(1, N):
    if max_v < arr[i]:
        max_v = arr[i]  # arr[i]가 더 크면 max_v 갱신
        
print(max_v)

# 배열 원소 중 최댓값의 인덱스 max_idx 찾기
max_idx = 0 # 첫 원소를 최대로 가정
for i in range(1, N):
    if arr[max_idx] < arr[i]:  # 더 큰값을 만나면
        max_idx = i  # max_idx 갱신

print(max_idx)

N, V = map(int, input().split())
arr = list(map(int, input().split()))
# 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기
idx = -1
for i in range(N):
    if arr[i] == V:
        idx = i
        break

print(idx)
```

### 연습 문제 (APS)

<aside>

상자들이 쌓여있는 방이 있다. 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, **낙차가 가장 큰 상자를 구하여 그 낙차를 리턴 하는 프로그램**을 작성해라.

상자 가로, 세로의 길이는 각각 1.

상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없음.

상자가 놓인 가로 칸의 수 N, 다음 줄에는 각 칸의 상자 높이를 입력 받음.

ex)

9

7 4 2 0 0 6 0 7 0

</aside>

→ 각 지역마다 오른쪽을 탐색하면서 이상의 숫자를 발견해 간다.

→ [7 4 3 2 1 2 1 1 0] → 제일 낙차가 큰 것은 7인 것을 발견할 수 있다.

## 정렬

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것

키(key) : 자료를 정렬하는 기준이 되는 특정 값

**버블 정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬** 등이 있음.

### 버블 정렬 (Bubble Sort)

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 형식

<aside>

첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

*ex)* [55, 7, 78, 12, 42] 버블 정렬

**55 7** 78 12 42 → 7 **55 78** 12 42 → 7 55 **78 12** 42 → 7 55 12 **78 42** → 7 55 12 42 **| 78**

→ **7 55** 12 42 **|** **78** → 7 **55 12** 42 **|** **78** → 7 12 **55 42** **|** **78** → 7 12 42 **| 55 78**

→ **7 12** 42 **|** **55 78** → 7 **12 42 |** **55 78** → 7 12 **|** **42 55 78**

→ **7 12** **|** **42 55 78** → 7 **|** **12 42 55 78**

→ **7 12 42 55 78**

</aside>

코드로 작성하면 아래와 같다.

```python
def bubblesort(a, N):
    for i in range(N-1, 0, -1):  # 정렬할 구간의 끝
        for j in range(i):  # 비교할 원소 중 왼쪽 원소의 인덱스(0부터 구간 마지막 인덱스-1)
            if a[j] > a[j+1]:  # 왼쪽 원소가 더 크면
                a[j], a[j+1] = a[j+1], a[j]  # 오른쪽 원소와 교환
```

### 카운팅 정렬 (Counting Sort)

O(n + k) : n은 리스트 길이, k는 정수의 최댓값

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, **선형 시간에 정렬하는 효율적인 알고리즘**

제한 사항은,

정수나 정수로 표현할 수 있는 자료에 대해서만 적용이 가능하다. → index를 사용하므로

카운트들을 위한 충분한 공간을 할당하려면 **집합 내의 가장 큰 정수를 알아야 한다.**

<aside>

*ex)* **[0, 4, 1, 3, 1, 2, 4, 1] 을 카운팅 정렬하는 과정**

**1단계**

DATA에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다.

COUNTS [0, 0, 0, 0, 0] → [1, 3, 1, 1, 2] (COUNTS[0] = 0의 발생 회수, COUNTS[i] = i의 발생 회수)

**2단계**

정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정한다.

COUNTS [1, 3, 1, 1, 2] → [1, 1+3, 1+3+1, 1+3+1+1, 1+3+1+1+2] → [1, 4, 5, 6, 8]

**3단계**

COUNTS[1]을 감소시키고 TEMP에 1을 삽입한다.

- 정렬 과정
    
    DATA [0, 4, 1, 3, 1, 2, 4, **1**] ← J = 7
    
    COUNTS [1, **4→3**, 5, 6, 8]
    
    TEMP [_, _, _, **1**, _, _, _, _]
    
    ---
    
    DATA [0, 4, 1, 3, 1, 2, **4**, 1] ← J = 6
    
    COUNTS [1, 3, 5, 6, **8→7**]
    
    TEMP [_, _, _, 1, _, _, _, **4**]
    
    ---
    
    DATA [0, 4, 1, 3, 1, **2**, 4, 1] ← J = 5
    
    COUNTS [1, 3, **5→4**, 6, 7]
    
    TEMP [_, _, _, 1, **2**, _, _, 4]
    
    ---
    
    DATA [0, 4, 1, 3, **1**, 2, 4, 1] ← J = 4
    
    COUNTS [1, **3→2**, 4, 6, 7]
    
    TEMP [_, _, **1**, 1, 2, _, _, 4]
    
    ---
    
    DATA [0, 4, 1, **3**, 1, 2, 4, 1] ← J = 3
    
    COUNTS [1, 2, 4, **6→5**, 7]
    
    TEMP [_, _, 1, 1, 2, **3**, _, 4]
    
    ---
    
    DATA [0, 4, **1**, 3, 1, 2, 4, 1] ← J = 2
    
    COUNTS [1, **2→1**, 4, 5, 7]
    
    TEMP [_, **1**, 1, 1, 2, 3, _, 4]
    
    ---
    
    DATA [0, **4**, 1, 3, 1, 2, 4, 1] ← J = 1
    
    COUNTS [1, 1, 4, 5, **7→6**]
    
    TEMP [_, 1, 1, 1, 2, 3, **4**, 4]
    
    ---
    
    DATA [**0**, 4, 1, 3, 1, 2, 4, 1] ← J = 0
    
    COUNTS [**1→0**, 1, 4, 5, 6]
    
    TEMP [**0**, 1, 1, 1, 2, 3, 4, 4]
    
    ---
    
    ⇒ TEMP [0, 1, 1, 1, 2, 3, 4, 4]
    
</aside>

위의 원리를 적용하여,

배열을 활용한 카운팅 정렬 코드를 작성하면 아래와 같다.

```python
'''
0<=DATA[i]<=4 조건
'''
DATA = [0, 4, 1, 3, 1, 2, 4, 1]
N = len(DATA)
COUNTS = [0] * 5  # max(DATA) + 1
TEMP = [0] * N  # 정렬 결과 저장

# 1단계 : 각 숫자의 개수
for i in range(N):
    COUNTS[DATA[i]] += 1

print(COUNTS)

# 2단계 : COUNTS[i]까지의 합계
for i in range(1,5):
    COUNTS[i] += COUNTS[i-1]

print(COUNTS)

# 3단계 : 정렬
for i in range(N-1, -1, -1):
    COUNTS[DATA[i]] -= 1
    TEMP[COUNTS[DATA[i]]] = DATA[i]

print(TEMP)
```

버블 정렬과 카운팅 정렬을 비교하자면,

**버블 정렬은 비교와 교환을 이용한 알고리즘**,

**카운팅 정렬은 비교환 방식을 이용한 알고리즘**이다.

각각의 시간 복잡도도 서로 다르다. (※ O(n^2), O(n+k))

## 완전 검색

### Baby-gin Game

<aside>

0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.

6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.

6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

*ex)*

667767 두 개의 triplet으로 baby-gin이다.

054060 한 개의 run과 한 개의 triplet이므로 역시 baby-gin이다.

…

</aside>

이 문제를 해결하려면 어떻게 해야 할까?

### 완전 검색

완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

*~~ㄷㄷ~~*

**Brute-force, generate-and-test** 기법이라고도 불린다.

모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.

일반적으로 경우의 수가 상대적으로 작을 때 유용하다!

모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

코드테스트 등과 같은 시험을 볼 때, 이 방법으로 접근을 먼저하고, 다른 알고리즘을 사용해보는 것이 좋을 것이다.

위의 Baby-gin Game을 완전 검색 방법으로 풀어보자.

<aside>

입력으로 [2, 3, 5, 7, 7, 7]을 받았다고 해보자.

2 3 5 7 7 7

2 3 7 5 7 7

2 3 7 7 5 7

…

앞의 3자리와 뒤의 3자리를 잘라, run과 triplet 여부를 테스트해보고, baby-gin을 판단한다.

2 3 5 7 7 7 → baby-gin 아님!

…

</aside>

### 순열

서로 다른 것들 몇 개를 뽑아서 한 줄로 나열하는 것

nPr = n * (n-1) * (n-2) * … * (n-r+1)

```python
# [1, 2, 3] 순열 만들기
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i1 != i2:
            for i3 in range(1, 4):
                if i1 != i3 and i2 != i3:
                    print(i1, i2, i3)

# [2, 3, 7] 순열 만들기
arr = [2, 3, 7]  # arr = [[2, 3, 7], [2, 7, 3], ... ]
for i1 in range(3):
    for i2 in range(3):
        if i1 != i2:
            for i3 in range(3):
                if i1 != i3 and i2 != i3:
                    print(arr[i1], arr[i2], arr[i3])
```

*숫자 3개 순열은 일일이 입력해 저장해 놓는 게 효율적임! 위에는 원리를 파악하기 위한 예시일 뿐.*

## 탐욕 알고리즘 (Greedy Algorithm)

탐욕 알고리즘은 **최적해를 구하는 데 사용되는 근시안적인 방법**이다.

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

각 선택의 시점에서 이루어지는 결정은 **지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.**

일반적으로, 머릿속에 떠오르는 **생각을 검증 없이 바로 구현하면 Greedy 접근**이 된다.

*그러니 조심스럽게 사용해야 함!*

<aside>

**동작 과정**

1. **해 선택** : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추간한다.
2. **실행 가능성 검사** : 새로운 부분해 집합이 실행 가능한지를 확인한다.
3. **해 검사** : 새로운 부분해 집한이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작한다.
</aside>

그럼, Baby-gin을 완전 검색 아닌 방법으로 풀어보자.

6개의 숫자는 6자리의 정수 값으로 입력된다.

counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.

<aside>

ex) COUNTS 배열(각 숫자가 적혀있는 횟수를 담고 있는 배열) 이용

444345 → COUNTS [_, _, 1, 4, 1, _, _, _, _, _]

run 빼기 → COUNTS [_, _, 0, 3, 0, _, _, _, _, _] → triplet 존재 → Baby-gin!

그러나 run을 먼저 빼고 triplet을 찾는다면 문제가 발생할 수도 있다.

이에 대한 해결 방법이 필요하다. **판별하는 순서가 중요**하겠다.

3이상인가? → 남는게 1이상인가? → 뒤에 숫자 중 1로 이어지는 게 있는가?

</aside>

코드를 구현하면 아래와 같다.

```python
num = int(input())  # Baby Gin 확인할 6자리 수
c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
              # 2개가 추가된 것은 padding. c[10], c[11]는 항상 0.

for i in range(6):
    c[num % 10] += 1  # 1의 자리를 알아내는 연산
    num //= 10  # 1의 자리를 제거하는 연산

i = 0
tri = run = 0
while i < 10:  # 카드 번호 9까지
    if c[i] >= 3:  # triplet 검증
        c[i] -= 3
        tri += 1
        continue

    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >=1:  # run 검증
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if tri + run == 2:
    print('Baby-Gin')
else:
    print('Lose')
```