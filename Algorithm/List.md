## 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

컴퓨터에 분야에서 알고리즘을 표현하는 방법은 크게 두 가지가 있다.

**의사 코드, 순서도**

좋은 알고리즘은 **정확성, 작업량, 메모리 사용량, 단순성, 최적성**을 고려한다.

많은 무제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

*ex)* 1부터 100까지 합을 구하는 문제

알고리즘1 : 100번의 연산 (1부터 순서대로 100까지 더함)

알고리즘2 : 100*(1+100)/2 = 5050 → 3번의 연산(덧셈 1번, 곱셈 1번, 나눗셈 1번)만 필요함.

알고리즘2가 알고리즘1보다 작업량이 적다.

이러한 작업량을 표현할 때 시간복잡도로 표현한다.

<aside>

**시간 복잡도 (Time Complexity)**

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산
</aside>

그러면 위의 예시는 다음과 같이 표현할 수 있겠다.

| **알고리즘 1** | **알고리즘 2** |
| --- | --- |
| 1 + n*2 = 2n + 1 | 3번의 연산 |

작업량을 보면 알고리즘1이 더 많은 것을 확인할 수 있다.

### 시간 복잡도 (빅-오 (O) 표기법)

시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하는 기법이다.

계수는 생략해서 표현한다.

*ex)*

O(3n + 2) = O(3n) = O(n)

O(4) = O(1)

O(2n^2 + 10n + 100) = O(n^2)

ex) n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간 복잡도는? → O(n)

요소 수가 증가함에 따가 각기 다른 시간복잡도의 알고리즘의 연산 수도 달라진다.

*ex)* N, logN, N, NlogN, N^2, N^3 …

## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

*ex)* num = [0,1,2,3,4,5]

프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.

배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.

단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

### 1차원 배열의 선언

arr = [1, 2, 3]

→ arr는 [1, 2, 3]을 가리키는 변수임.

→ 배열은 각 자리마다 인덱스 번호가 있다.

### 배열 연산

```python
# 첫 줄에 양수의 개수 N이 주어진다. (5 <= N <= 1000)
# 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어진다. (1 <= Ai <= 1000000)

N = int(input())  # 입력예 : 6
arr = list(map(int, input().split()))  # 입력예 : 2 7 5 3 1 4

# 배열원소의 합 s 구하기
s = 0
for i in range(N):  # 모든 원소에 대해
    s += arr[i]

print(s)

# 배열 원소 중 최댓값 max_v 찾기
max_v = arr[0]
for i in range(1, N):
    if max_v < arr[i]:
        max_v = arr[i]  # arr[i]가 더 크면 max_v 갱신
        
print(max_v)

# 배열 원소 중 최댓값의 인덱스 max_idx 찾기
max_idx = 0 # 첫 원소를 최대로 가정
for i in range(1, N):
    if arr[max_idx] < arr[i]:  # 더 큰값을 만나면
        max_idx = i  # max_idx 갱신

print(max_idx)

N, V = map(int, input().split())
arr = list(map(int, input().split()))
# 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기
idx = -1
for i in range(N):
    if arr[i] == V:
        idx = i
        break

print(idx)
```

### 연습 문제 (APS)

<aside>

상자들이 쌓여있는 방이 있다. 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, **낙차가 가장 큰 상자를 구하여 그 낙차를 리턴 하는 프로그램**을 작성해라.

상자 가로, 세로의 길이는 각각 1.

상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없음.

상자가 놓인 가로 칸의 수 N, 다음 줄에는 각 칸의 상자 높이를 입력 받음.

ex)

9

7 4 2 0 0 6 0 7 0

</aside>

→ 각 지역마다 오른쪽을 탐색하면서 이상의 숫자를 발견해 간다.

→ [7 4 3 2 1 2 1 1 0] → 제일 낙차가 큰 것은 7인 것을 발견할 수 있다.

## 정렬

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것

키(key) : 자료를 정렬하는 기준이 되는 특정 값

**버블 정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬** 등이 있음.

### 버블 정렬 (Bubble Sort)

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 형식

<aside>

첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

*ex)* [55, 7, 78, 12, 42] 버블 정렬

**55 7** 78 12 42 → 7 **55 78** 12 42 → 7 55 **78 12** 42 → 7 55 12 **78 42** → 7 55 12 42 **| 78**

→ **7 55** 12 42 **|** **78** → 7 **55 12** 42 **|** **78** → 7 12 **55 42** **|** **78** → 7 12 42 **| 55 78**

→ **7 12** 42 **|** **55 78** → 7 **12 42 |** **55 78** → 7 12 **|** **42 55 78**

→ **7 12** **|** **42 55 78** → 7 **|** **12 42 55 78**

→ **7 12 42 55 78**

</aside>

코드로 작성하면 아래와 같다.

```python
def bubblesort(a, N)
    for i in range(N-1, 0, -1):  # 정렬할 구간의 끝
		for j in range(i):  # 비교할 원소 중 왼쪽 원소의 인덱스(0부터 구간 마지막 인덱스-1)
			if a[j] > a[j+1]:  # 왼쪽 원소가 더 크면
				a[j], a[j+1] = a[j+1], a[j]  # 오른쪽 원소와 교환
```