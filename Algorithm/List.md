## 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

컴퓨터에 분야에서 알고리즘을 표현하는 방법은 크게 두 가지가 있다.

**의사 코드, 순서도**

좋은 알고리즘은 **정확성, 작업량, 메모리 사용량, 단순성, 최적성**을 고려한다.

많은 무제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

*ex)* 1부터 100까지 합을 구하는 문제

알고리즘1 : 100번의 연산 (1부터 순서대로 100까지 더함)

알고리즘2 : 100*(1+100)/2 = 5050 → 3번의 연산(덧셈 1번, 곱셈 1번, 나눗셈 1번)만 필요함.

알고리즘2가 알고리즘1보다 작업량이 적다.

이러한 작업량을 표현할 때 시간복잡도로 표현한다.

<aside>

**시간 복잡도 (Time Complexity)**

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산
</aside>

그러면 위의 예시는 다음과 같이 표현할 수 있겠다.

| **알고리즘 1** | **알고리즘 2** |
| --- | --- |
| 1 + n*2 = 2n + 1 | 3번의 연산 |

작업량을 보면 알고리즘1이 더 많은 것을 확인할 수 있다.

### 시간 복잡도 (빅-오 (O) 표기법)

시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하는 기법이다.

계수는 생략해서 표현한다.

*ex)*

O(3n + 2) = O(3n) = O(n)

O(4) = O(1)

O(2n^2 + 10n + 100) = O(n^2)

ex) n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간 복잡도는? → O(n)

요소 수가 증가함에 따가 각기 다른 시간복잡도의 알고리즘의 연산 수도 달라진다.

*ex)* N, logN, N, NlogN, N^2, N^3 …

## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

*ex)* num = [0,1,2,3,4,5]

프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.

배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.

단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

### 1차원 배열의 선언

arr = [1, 2, 3]

→ arr는 [1, 2, 3]을 가리키는 변수임.

→ 배열은 각 자리마다 인덱스 번호가 있다.

### 배열 연산

```python
# 첫 줄에 양수의 개수 N이 주어진다. (5 <= N <= 1000)
# 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어진다. (1 <= Ai <= 1000000)

N = int(input())  # 입력예 : 6
arr = list(map(int, input().split()))  # 입력예 : 2 7 5 3 1 4

# 배열원소의 합 s 구하기
s = 0
for i in range(N):  # 모든 원소에 대해
    s += arr[i]

print(s)

# 배열 원소 중 최댓값 max_v 찾기
max_v = arr[0]
for i in range(1, N):
    if max_v < arr[i]:
        max_v = arr[i]  # arr[i]가 더 크면 max_v 갱신
        
print(max_v)

# 배열 원소 중 최댓값의 인덱스 max_idx 찾기
max_idx = 0 # 첫 원소를 최대로 가정
for i in range(1, N):
    if arr[max_idx] < arr[i]:  # 더 큰값을 만나면
        max_idx = i  # max_idx 갱신

print(max_idx)

N, V = map(int, input().split())
arr = list(map(int, input().split()))
# 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기
idx = -1
for i in range(N):
    if arr[i] == V:
        idx = i
        break

print(idx)
```

### 연습 문제 (APS)

<aside>

상자들이 쌓여있는 방이 있다. 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, **낙차가 가장 큰 상자를 구하여 그 낙차를 리턴 하는 프로그램**을 작성해라.

상자 가로, 세로의 길이는 각각 1.

상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없음.

상자가 놓인 가로 칸의 수 N, 다음 줄에는 각 칸의 상자 높이를 입력 받음.

ex)

9

7 4 2 0 0 6 0 7 0

</aside>

→ 각 지역마다 오른쪽을 탐색하면서 이상의 숫자를 발견해 간다.

→ [7 4 3 2 1 2 1 1 0] → 제일 낙차가 큰 것은 7인 것을 발견할 수 있다.

## 정렬

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것

키(key) : 자료를 정렬하는 기준이 되는 특정 값

**버블 정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬** 등이 있음.

### 버블 정렬 (Bubble Sort)

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 형식

<aside>

첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

*ex)* [55, 7, 78, 12, 42] 버블 정렬

**55 7** 78 12 42 → 7 **55 78** 12 42 → 7 55 **78 12** 42 → 7 55 12 **78 42** → 7 55 12 42 **| 78**

→ **7 55** 12 42 **|** **78** → 7 **55 12** 42 **|** **78** → 7 12 **55 42** **|** **78** → 7 12 42 **| 55 78**

→ **7 12** 42 **|** **55 78** → 7 **12 42 |** **55 78** → 7 12 **|** **42 55 78**

→ **7 12** **|** **42 55 78** → 7 **|** **12 42 55 78**

→ **7 12 42 55 78**

</aside>

코드로 작성하면 아래와 같다.

```python
def bubblesort(a, N):
    for i in range(N-1, 0, -1):  # 정렬할 구간의 끝
        for j in range(i):  # 비교할 원소 중 왼쪽 원소의 인덱스(0부터 구간 마지막 인덱스-1)
            if a[j] > a[j+1]:  # 왼쪽 원소가 더 크면
                a[j], a[j+1] = a[j+1], a[j]  # 오른쪽 원소와 교환
```

### 카운팅 정렬 (Counting Sort)

O(n + k) : n은 리스트 길이, k는 정수의 최댓값

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, **선형 시간에 정렬하는 효율적인 알고리즘**

제한 사항은,

정수나 정수로 표현할 수 있는 자료에 대해서만 적용이 가능하다. → index를 사용하므로

카운트들을 위한 충분한 공간을 할당하려면 **집합 내의 가장 큰 정수를 알아야 한다.**

<aside>

*ex)* **[0, 4, 1, 3, 1, 2, 4, 1] 을 카운팅 정렬하는 과정**

**1단계**

DATA에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다.

COUNTS [0, 0, 0, 0, 0] → [1, 3, 1, 1, 2] (COUNTS[0] = 0의 발생 회수, COUNTS[i] = i의 발생 회수)

**2단계**

정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정한다.

COUNTS [1, 3, 1, 1, 2] → [1, 1+3, 1+3+1, 1+3+1+1, 1+3+1+1+2] → [1, 4, 5, 6, 8]

**3단계**

COUNTS[1]을 감소시키고 TEMP에 1을 삽입한다.

- 정렬 과정
    
    DATA [0, 4, 1, 3, 1, 2, 4, **1**] ← J = 7
    
    COUNTS [1, **4→3**, 5, 6, 8]
    
    TEMP [_, _, _, **1**, _, _, _, _]
    
    ---
    
    DATA [0, 4, 1, 3, 1, 2, **4**, 1] ← J = 6
    
    COUNTS [1, 3, 5, 6, **8→7**]
    
    TEMP [_, _, _, 1, _, _, _, **4**]
    
    ---
    
    DATA [0, 4, 1, 3, 1, **2**, 4, 1] ← J = 5
    
    COUNTS [1, 3, **5→4**, 6, 7]
    
    TEMP [_, _, _, 1, **2**, _, _, 4]
    
    ---
    
    DATA [0, 4, 1, 3, **1**, 2, 4, 1] ← J = 4
    
    COUNTS [1, **3→2**, 4, 6, 7]
    
    TEMP [_, _, **1**, 1, 2, _, _, 4]
    
    ---
    
    DATA [0, 4, 1, **3**, 1, 2, 4, 1] ← J = 3
    
    COUNTS [1, 2, 4, **6→5**, 7]
    
    TEMP [_, _, 1, 1, 2, **3**, _, 4]
    
    ---
    
    DATA [0, 4, **1**, 3, 1, 2, 4, 1] ← J = 2
    
    COUNTS [1, **2→1**, 4, 5, 7]
    
    TEMP [_, **1**, 1, 1, 2, 3, _, 4]
    
    ---
    
    DATA [0, **4**, 1, 3, 1, 2, 4, 1] ← J = 1
    
    COUNTS [1, 1, 4, 5, **7→6**]
    
    TEMP [_, 1, 1, 1, 2, 3, **4**, 4]
    
    ---
    
    DATA [**0**, 4, 1, 3, 1, 2, 4, 1] ← J = 0
    
    COUNTS [**1→0**, 1, 4, 5, 6]
    
    TEMP [**0**, 1, 1, 1, 2, 3, 4, 4]
    
    ---
    
    ⇒ TEMP [0, 1, 1, 1, 2, 3, 4, 4]
    
</aside>

위의 원리를 적용하여,

배열을 활용한 카운팅 정렬 코드를 작성하면 아래와 같다.

```python
'''
0<=DATA[i]<=4 조건
'''
DATA = [0, 4, 1, 3, 1, 2, 4, 1]
N = len(DATA)
COUNTS = [0] * 5  # max(DATA) + 1
TEMP = [0] * N  # 정렬 결과 저장

# 1단계 : 각 숫자의 개수
for i in range(N):
    COUNTS[DATA[i]] += 1

print(COUNTS)

# 2단계 : COUNTS[i]까지의 합계
for i in range(1,5):
    COUNTS[i] += COUNTS[i-1]

print(COUNTS)

# 3단계 : 정렬
for i in range(N-1, -1, -1):
    COUNTS[DATA[i]] -= 1
    TEMP[COUNTS[DATA[i]]] = DATA[i]

print(TEMP)
```

버블 정렬과 카운팅 정렬을 비교하자면,

**버블 정렬은 비교와 교환을 이용한 알고리즘**,

**카운팅 정렬은 비교환 방식을 이용한 알고리즘**이다.

각각의 시간 복잡도도 서로 다르다. (※ O(n^2), O(n+k))

## 완전 검색

### Baby-gin Game

<aside>

0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.

6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.

6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

*ex)*

667767 두 개의 triplet으로 baby-gin이다.

054060 한 개의 run과 한 개의 triplet이므로 역시 baby-gin이다.

…

</aside>

이 문제를 해결하려면 어떻게 해야 할까?

### 완전 검색

완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

*~~ㄷㄷ~~*

**Brute-force, generate-and-test** 기법이라고도 불린다.

모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.

일반적으로 경우의 수가 상대적으로 작을 때 유용하다!

모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

코드테스트 등과 같은 시험을 볼 때, 이 방법으로 접근을 먼저하고, 다른 알고리즘을 사용해보는 것이 좋을 것이다.

위의 Baby-gin Game을 완전 검색 방법으로 풀어보자.

<aside>

입력으로 [2, 3, 5, 7, 7, 7]을 받았다고 해보자.

2 3 5 7 7 7

2 3 7 5 7 7

2 3 7 7 5 7

…

앞의 3자리와 뒤의 3자리를 잘라, run과 triplet 여부를 테스트해보고, baby-gin을 판단한다.

2 3 5 7 7 7 → baby-gin 아님!

…

</aside>

### 순열

서로 다른 것들 몇 개를 뽑아서 한 줄로 나열하는 것

nPr = n * (n-1) * (n-2) * … * (n-r+1)

```python
# [1, 2, 3] 순열 만들기
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i1 != i2:
            for i3 in range(1, 4):
                if i1 != i3 and i2 != i3:
                    print(i1, i2, i3)

# [2, 3, 7] 순열 만들기
arr = [2, 3, 7]  # arr = [[2, 3, 7], [2, 7, 3], ... ]
for i1 in range(3):
    for i2 in range(3):
        if i1 != i2:
            for i3 in range(3):
                if i1 != i3 and i2 != i3:
                    print(arr[i1], arr[i2], arr[i3])
```

*숫자 3개 순열은 일일이 입력해 저장해 놓는 게 효율적임! 위에는 원리를 파악하기 위한 예시일 뿐.*

## 탐욕 알고리즘 (Greedy Algorithm)

탐욕 알고리즘은 **최적해를 구하는 데 사용되는 근시안적인 방법**이다.

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

각 선택의 시점에서 이루어지는 결정은 **지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.**

일반적으로, 머릿속에 떠오르는 **생각을 검증 없이 바로 구현하면 Greedy 접근**이 된다.

*그러니 조심스럽게 사용해야 함!*

<aside>

**동작 과정**

1. **해 선택** : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추간한다.
2. **실행 가능성 검사** : 새로운 부분해 집합이 실행 가능한지를 확인한다.
3. **해 검사** : 새로운 부분해 집한이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작한다.
</aside>

그럼, Baby-gin을 완전 검색 아닌 방법으로 풀어보자.

6개의 숫자는 6자리의 정수 값으로 입력된다.

counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다.

<aside>

ex) COUNTS 배열(각 숫자가 적혀있는 횟수를 담고 있는 배열) 이용

444345 → COUNTS [_, _, 1, 4, 1, _, _, _, _, _]

run 빼기 → COUNTS [_, _, 0, 3, 0, _, _, _, _, _] → triplet 존재 → Baby-gin!

그러나 run을 먼저 빼고 triplet을 찾는다면 문제가 발생할 수도 있다.

이에 대한 해결 방법이 필요하다. **판별하는 순서가 중요**하겠다.

3이상인가? → 남는게 1이상인가? → 뒤에 숫자 중 1로 이어지는 게 있는가?

</aside>

코드를 구현하면 아래와 같다.

```python
num = int(input())  # Baby Gin 확인할 6자리 수
c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
              # 2개가 추가된 것은 padding. c[10], c[11]는 항상 0.

for i in range(6):
    c[num % 10] += 1  # 1의 자리를 알아내는 연산
    num //= 10  # 1의 자리를 제거하는 연산

i = 0
tri = run = 0
while i < 10:  # 카드 번호 9까지
    if c[i] >= 3:  # triplet 검증
        c[i] -= 3
        tri += 1
        continue

    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >=1:  # run 검증
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if tri + run == 2:
    print('Baby-Gin')
else:
    print('Lose')
```

## 2차원 배열

1차원 List를 묶어놓은 List

2차원 이상의 다차원 List는 차원에 따라 Index를 선언

```python
arr = [[0,1,2,3],[4,5,6,7]]

# 입력을 2차원 배열에 저장하기 (띄어쓰기로)
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
'''
3
1 2 3
4 5 6
7 8 9
[
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
}
'''

# 입력을 2차원 배열에 저장하기 (붙어 있는 상태로)
N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
'''
3
123
456
789
[
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
]
'''
```

```python
N = int(input())
arr_0 = [[0 for _ in range(N)] for _ in range(N)]
print(arr_0) # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

arr_0[2][1] = 1
print(arr_0) # [[0, 0, 0], [0, 0, 0], [0, 1, 0]]

# 밑에 코드는 얕은 복사(shallow copy)가 된다.. 주의하자!!
arr_0 = [[0] * N] * N
print(arr_0) # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

arr_0[2][1] = 1
print(arr_0) # [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
```

### 배열 순회

n * m개의 모든 원소를 빠짐없이 조사하는 방법

```python
for i in range(N):
    for j in range(N):
        print(arr_1[i][j])
        
# 배열 요소들의 합을 구하는 방법
s = 0
for i in range(N):
    for j in range(M):
        s += arr[i][j]
        
# 열 우선 순회, *i와 j가 바뀐다고 생각하면 됨.*
for j in range(M):
    for i in range(N):
        print(arr[i][j])
        
# 지그재그 순회
# 방법.1
for i in range(N):
    if i%2 == 0:
        for j in range(M):
            print(arr[i][j])
    else:
        for j in range(M,-1,-1):
            print(arr[i][j])

# 방법.2
for i in range(N):
    for j in range(M):
        print(arr[i][j + (M-1-2*j) * (i%2)]) # (i%2)는 행이 홀수, 짝수를 판단
```

## 델타

2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

```python
# 오른쪽부터 시계 방향으로 탐색
# 방법.1
di = [0, 1, 0, -1] # 하,상
dj = [1, 0, -1, 0] # 우,좌

N = 2
M = 3
for i in range(N):
    for j in range(M):
        for dir in range(4):
            ni = i + di[dir]
            nj = j + dj[dir]
            if 0<=ni<N and 0<=nj<M:
                print(ni, nj)
 
                
# 방법.2
for i in range(N):
    for j in range(M):
        for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:
            ni, nj = i+di, j+dj
            if 0<=ni<N and 0<=nj<M:
                print(ni, nj)
```

### 델타 응용

NxN 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최대값 (k=2)

```python
# 델타 응용
# NxN 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최대값 (k=2)
max_v = 0
k = 2
for i in range(N):
    for j in range(N):
        s = arr[i][j]
        for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:
            for c in range(1, k+1):
                ni, nj = i+di*c, j+dj*c
                if 0<=ni<N and 0<=nj<N:
                    s += arr[ni][nj]

        if max_v < s:
            max_v = s
```

### 전치 행렬

```python
for i in range(3):
		for j in range(3):
				if i < j:
						arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

### 참고

**i < j**

|  | O | O |
| --- | --- | --- |
|  |  | O |
|  |  |  |

**i > j**

|  |  |  |
| --- | --- | --- |
| O |  |  |
| O | O |  |

**i = j**

| O |  |  |
| --- | --- | --- |
|  | O |  |
|  |  | O |

**N-1-i = j**

|  |  | O |
| --- | --- | --- |
|  | O |  |
| O |  |  |

### 연습문제

<aside>
💡

**5x5 2차원 배열에 25개의 숫자를 저장하고, 대각선 원소의 합을 구하시오.**

</aside>

```python
arr = [list(map(int,input().split())) for _ in range(5)]
hap = 0
for i in range(5):
    hap += arr[i][i] + arr[4-i][i]

hap -= arr[2][2]

print(hap)
```

## 부분집합 합(Subset Sum) 문제

유한개의 정수로 이루어진 집합이 있을 대, **이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우**가 있는 지를 알아내는 문제

예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 대, [-3, -2, 5]는 이 집합의 부분집합이면서 (-3)+(-2)+5 =0이므로 이 경우의 답은 참이 된다.

### 부분집합의 수

집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.

이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

*ex)* {1, 2, 3, 4} → 2 * 2 * 2 * 2 = 16가지

부분집합 원소를 표현하는 방법은 아래와 같이 표시해볼 수 있겠다.

| **arr [1, 2, 3]** | **bit** |
| --- | --- |
|  | 0 0 0 |
| 3 | 0 0 1 |
| 2 | 0 1 0 |
| 2, 3 | 0 1 1 |
| 1 | 1 0 0 |
| 1, 3 | 1 1 0 |
| 1, 2, 3 | 1 1 1 |

이것을 코드로 표현하면 다음과 같다.

```python
arr = [2, 3, 7]
bit = [0, 0, 0]

for i in range(2):  # 0번 원소
    bit[0] = i
    for j in range(2):  # 1번 원소
        bit[1] = j
        for k in range(2):  # 2번 원소
            bit[2] = k
            s = 0    # 부분집합의 합
            for b in range(3):
                if bit[b]:
                    s += arr[b]
                    print(arr[b], end= ' ')  # 부분집합에 포함된 원소
            print(bit, s)
```

`for` 문을 사용해서 표현해볼 수 있겠다.

그런데,

현재는 4개의 원소만 있어서 괜찮지만, 원소가 많아지면 어떻게 감당할까..?

### 비트 연산자

| **&** | 비트 단위로 AND 연산을 한다. |
| --- | --- |
| **|** | 비트 단위로 OR 연산을 한다. |
| **<<** | 피연산자의 비트 열을 왼쪽으로 이동시킨다. |
| **>>** | 피연산자의 비트 열을 오른쪽으로 이동시킨다. |

<aside>

`1 << n` = 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

ex) (1 = )00001₂ → 00010₂ → 00100₂ → 01000₂ …

`i & (1 << j)` : i의 j번째 비트가 1인지 아닌지를 검사한다.

</aside>

이 비트 연산자를 이용하면,

부분집합을 구하는 코드가 단순해질 수 있다.

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)

for i in range(1<<n):  # 1<<n은 부분집합의 개수, i는 10진법으로 숫자 하나씩 탐색!
    for j in range(n):
        if i & (1<<j):  # i의 j번 비트가 1인 경우
								        # 000111 & 000011 -> 000011 -> 3과 6 출력.
            print(arr[j], end=", ")
    print()
print()
```

## 검색

저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

<aside>

**탐색 키 (search key)** : 자료를 구별하여 인식할 수 있는 키

</aside>

검색의 종류는 **순차 검색(sequential search), 이진 검색(binary search), 해쉬(hash)** 등이 있다.

### 순차 검색 (sequential search)

**일렬로 되어 있는 자료를 순서대로 검색하는 방법**

가장 간단하고 직관적인 검색 방법

배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용하다.

알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행 시간이 급격히 증가하여 비효율적임

경우는 2가지가 주어진다. → **정렬되어 있지 않는 경우, 정렬되어 있는 경우**

- **정렬되어 있지 않는 경우**
    
    첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
    
    키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
    
    자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
    
    평균 비교 회수를 반영한 **시간 복잡도**는 (1/n)*(1+2+3 … +n) = (n+1)/2 = **O(n)**
    
    <aside>
    
    *ex)*
    
    [ 4, 9, 11, 23, 2, 19, 7 ]
    
    → 2를 찾으려고 한다.
    
    0번째 실패, 1번째 실패, 2번째 실패 … 4번째 찾음!
    
    → 8을 찾으려고 한다.
    
    0번째 실패, 1번째 실패, … 6번째 실패, 검색 실패!
    
    </aside>
    
    ```python
    def seq_search(a, n, key):
        for i in range(n):
            if a[i] == key:
                return 1
        return -1
    
    arr = [4, 9, 11, 23, 2, 19, 7]
    print(seq_search(arr, len(arr), 8))  # -1
    ```
    
    *함수 선언이 익숙하지 않으면 연습을 많이 해 놓을 것!*
    
    ```python
    arr = [[1,2,3],[4,5,6],[7,8,9]]
    
    N = 3
    key = 5
    ans = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j] == key:
                ans = 1
                break
    
    print(ans)  # 1
    ```
    
- **정렬되어 있는 경우**
    
    자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정하자.
    
    자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료한다.
    
    정렬이 되어 있으므로, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어든다!
    
    **시간 복잡도**는 **O(n).**
    
    <aside>
    
    *ex)*
    
    [2, 4, 7, 9, 11, 19, 23]
    
    → 10을 검색하는 경우
    
    0번째 실패(2 < 10), 1번째 실패(2 < 10), … 4번째(11 > 10) 실패, 검색 실패!
    
    끝까지 탐색할 필요가 없어진다.
    
    </aside>
    
    ```python
    def seq_search(a, n, key):
        for i in range(n):
            if a[i] == key:
                return i
            elif a[i] > key:
                return -1
        return -1       # 모든 원소가 key보다 작으면
    
    arr = [4, 9, 11, 23, 2, 19, 7]
    
    arr.sort()
    print(arr)  # [2, 4, 7, 9, 11, 19, 23]
    print(seq_search(arr, len(arr), 11))  # 1
    print(seq_search(arr, len(arr), 100))  # -1
    ```
    

### 이진 검색 (Binary Search)

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

**이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.**

검색 범위의 **시작점과 종료점**을 이용하여 **검색을 반복 수행**한다.

이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 **배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요**하다!

- **검색 과정**
    1. 자료의 중앙에 있는 원소를 고른다.
    2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
    3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
    4. 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.
    
    <aside>
    
    *ex1)*
    
    [ 2, 4, 7, 9, 11, 19, 23 ]
    
    → 이진 검색으로 7를 찾는다. 과정에는 검색 구간의 **시작 점, 끝점, 중앙점**이 주어져야 한다.
    
    → [ 2, 4, 7 | **9** | 11, 19, 23 ] 7보다 9가 큼. 검색 범위는 왼쪽 구간으로 변경 
    
    → [ 2 | **4** | 7  ~~9, 11, 19, 23~~ ] 7보다 4가 작음. 검색 범위는 오른쪽 구간으로 변경
    
    → [ ~~2, 4~~ | **7** | ~~9, 11, 19, 23~~ ] 7과 7이 동일. (검색은 계속 진행되어야 함.) 7 검색 성공!
    
    *ex2)*
    
    [ 2, 4, 7, 9, 11, 19, 23 ]
    
    → 이진 검색으로 20를 찾는다. 과정에는 검색 구간의 **시작 점, 끝점, 중앙점**이 주어져야 한다.
    
    → [ 2, 4, 7 | **9** | 11, 19, 23 ] 20보다 9가 작음. 검색 범위는 오른쪽 구간으로 변경 
    
    → [ ~~2, 4, 7, 9~~  11 | **19** | 23 ] 20보다 19가 작음. 검색 범위는 오른쪽 구간으로 변경
    
    → [ ~~2, 4, 7, 9, 11, 19~~ | **23** | ] 20보다 23이 큼. (검색은 계속 되어야 함.) 왼쪽 구간으로 변경
    
    →  왼쪽 구간이 존재하지 않음! 20 검색 실패!
    
    </aside>
    
    만약 **검색 구간 요소 개수가 짝수라면 중앙값은 어떻게 하지?**
    
    **정수의 나눗셈**이 적용된다.
    
    *ex)* (0+3) // 2 = 1
    
    ```python
    def binary_search(a, n, key):
        start = 0
        end = n-1
        while start <= end:  # 검색 구간에 1개 이상의 원소가 있으면 검색
            middle = (start + end) // 2  # 기준 위치 계산
            if a[middle] == key:  # 검색 성공!
                return middle  # 인덱스를 리턴해줌.
            elif a[middle] > key:  # 키보다 크면 왼쪽 구간 선택
                end = middle - 1
            else:  # a[middle] < key, 키보다 작으면 오른쪽 구간 선택
                start = middle + 1
        return -1  # 검색구간이 남아있지 않으면, 검색 실패
    
    arr = [2, 4, 7, 9, 11, 19, 23]  # 오름차순 정렬된 배열
    print(binary_search(arr, 7, 11))  # 1
    print(binary_search(arr, 7, 100))  # -1
    print(binary_search(arr, 7, 24))  # -1
    ```
    

### 인덱스

원본 데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠르다.

인덱스라는 용어는 Database에서 유래됐으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다.

Database 분야가 아닌 곳에서는 **Look up table** 등의 용어를 사용하기도 한다.

인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다.

대량의 데이터를 매번 정렬하면, 프로그램의 반응은 느려질 수 밖에 없다.

이러한 대량 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용할 수 있다.

데이터베이스 인덱스는 **이진 탐색 트리** 구조로 되어있다.

## 선택 정렬 (Selection Sort)

주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식 (오름차순의 경우)

**시간 복잡도**는 **O(n^2)**

*선택 정렬은 교환의 회수가 버블, 삽입 정렬보다 작다.*

- **정렬 과정**
    1. 주어진 리스트 중에서 최소값을 찾는다.
    2. 그 값을 리스트이 맨 앞에 위치한 값과 교환한다.
    3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
    
    <aside>
    
    *ex)* [64, 25, 10, 22, 11] 선택 정렬
    
    → [64, 25, **10**, 22, 11] 주어진 리스트에서 최소값을 기준 위치부터 찾는다.
    
    → [**10** | 25, **64**, 22, 11] 리스트의 맨 앞에 위치한 값과 교환한다.
    
    → [10 | 25, 64, 22, **11**] 미정렬 리스트에서 최소값을 찾는다.
    
    → [10, **11** | 64, 22, **25**] 리스트의 맨 앞과 위치한 값과 교환된다.
    
    → [10, 11 | 64, **22**, 25] 미정렬 리스트에서 최소값을 찾는다.
    
    → [10, 11, **22** | **64**, 25] 리스트이 맨 앞에 위치한 값과 교환된다.
    
    → [10, 11, 22 | 64, **25**] 미정렬 리스트에서 최소값을 찾는다.
    
    → [10, 11, 22, **25** | **64**]리스트의 맨 앞에 위치한 값과 교환된다.
    
    → 미정렬 원소가 하나 남은 상황에서는 마지막 원소가 가장 큰 값을 갖게 되므로, 실행을 종료하고 선택 정렬이 완료된다.
    
    </aside>
    
    ```python
    def selection_sort(a, N):
        for i in range(N-1):  # 기준위치(최솟값을 찾는 구간의 시작)
            min_idx = i  # 최솟값 인덱스 초기화, 구간의 맨 앞 원소를 최소로 가정
            for j in range(i+1, N):  # 실제 최솟값인지 비교하는 위치
                if a[min_idx] > a[j]:
                    min_idx = j
            a[i], a[min_idx] = a[min_idx], a[i]
    
    arr = [10, 25, 64, 22, 11]
    
    selection_sort(arr, len(arr))
    print(arr)  # [10, 11, 22, 25, 64]
    ```
    

### 셀렉션 알고리즘 (Selection Algorithm)

저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.

최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.

셀렉션은 **정렬 알고리즘을 이용하여 자료를 정렬하고, 원하는 순서에 있는 원소를 가져오는** 원리가 이용된다.

- **k번째로 작은 원소를 찾는 알고리즘**
    
    1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환한다.
    
    k가 비교적 작을 때 유용하며 **O(kn)**의 수행시간을 필요로 한다.