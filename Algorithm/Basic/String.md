## 문자의 표현

글자 A를 메모리에 저장하는 방법에 대해서 생각해보자

메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한 각 문자에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이 사용될 것이다.

영어가 대소문자 합쳐서 52자 이므로 6(64가지)비트면 모두 표현할 수 있다.

이를 **코드 체계**라고 한다.

*ex)* 000000 → ‘a’,  000001 → ‘b’

```python
print(f'{ord("대"):x}')  # x는 16진수를 표현하기 위해 존재
print(chr(0xb300))  # 0x : 16진수 표현 방법
```

네트워크가 발전되기 전 미국의 각 지역 별로 코드 체계를 정해 놓고 사용했지만,

네트워크가 발전하면서 서로 간에 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.

그래서 혼동을 피하기 위해 표준안을 만들었으며,

1967년 미국에서 **ASCII**라는 문자 인코딩 표준이 제정되었다.

### ASCII **(American Standard Code for Information Interchange)**

7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.

*ex)* 65 → A, 97 → a …

**확장 아스키**는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.

**확장 아스키**는 1Byte 내의 8-bit를 모두 사용한다.

확장 아스키는 세계적으로 통용되는 표준 아스키에 비해, 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.

오늘 날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII 형식을 사용한다.

하지만, 각 나라에서도 컴퓨터가 발전했으며 각 국가들의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 되었다.

다국어 처리를 위해 표준을 마련한 것이 **유니코드**이다.

유니코드도 다시 **Character Set**으로 분류된다.

UCS-2, UCS-4 → 유니코드를 저장하는 변수의 크기를 정의한다.

그러나 바이트 순서에 대해서 표준화하지 못했다. → 파일을 인식 시 파일이 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생한다.

유니코드의 적당한 외부 인코딩이 필요하게 되었다.

### 유니코드 인코딩 (UTF : Unicode Transformation Format)

<aside>

**UTF-8** (in web) - min : 8bit, max : 32bit (1Byte * 4)

*ex)* (실제로 정보가 들어가 있는 부분은 x 부분임.)

0xxxxxxx

110xxxxx  10xxxxxx

1110xxxx  10xxxxxx  10xxxxxx

11110xxx  10xxxxxx  10xxxxxx  10xxxxxx

**UTF-16** (in Windows, Java) - min : 16bit, max : 32bit

**UTF-32** (in Unix) - min : 32bit, max : 32bit

</aside>

ex)

```python
# [test.txt]
ABC
한글
```

위의 파일을 인코딩해본다고 생각해보자.

UTF-8 → 41 42 43 0D 0A ED ….

UTF-16BE (Big Endian) → FE FF 00 41 00 42 00 43 00 …

인코딩 별로 기록하는 바이트 크기가 다름을 알 수 있다.

*처음에 Python 프로그래밍도 ASCII 코드로 되어 있으므로,* `coding: utf-8` *이라고 첫 줄에 명시했어야 했다. 지금은 생략 가능하다.*

*다른 인코딩 방식으로 프로그래밍 하고 싶다면 위 항목에 원하는 인코딩 방식을 지정해주면 된다.*

## 문자열

### 문자열 처리

**C언어**에서는,

문자열은 문자들의 배열 형태로 구현된 응용 자료형이며, 문자배열에 문자열을 저장할 때는 항상 마지막에 끝을 표시하는 ‘\0’을 넣어줘야 한다.

```c
char arr[] = "abc";
char arr[] = {'a', 'b', 'c', '\0'};
```

문자열 처리에 필요한 연산을 함수 형태로 제공한다.

`strlen()` , `strcpy()` , `strcmp()` …

**java**에서는,

java.lang.String 클래스에는 기본적인 객체 메타 데이터 외에도 네가지 필드들이 포함되어 있는데, hash값, 문자열의 길이, 문자열 데이터의 시작점, 그리고 실제 문자열 배열에 대한 참조이다.

문자열 데이터를 저장, 처리해주는 클래스를 제공해주며, String 클래스를 사용한다.

```java
String str = "abc"
String str = new String("abc")
```

문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다. 보다 풍부한 연산을 제공한다.

`+`, `length()` , `replace()` , `split()` , `substring()` …

**Python**에서는,

char 타입이 없고, 텍스트 데이터의 취급 방법이 통일되어 있다.

`+`: 연결 (Concatenation), `*`: 반복 …

문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있다.

`replace()` , `split()` , `isalpha()` , `find()`

문자열은 튜플과 같이 요소값을 변경할 수 없다.

기본적인 차이점은,

C는 아스키 코드로 저장한다.

java는 유니코드(UTF16, 2byte)로 저장한다.

Python은 유니코드(UTF8)로 저장한다.

```c
// C언어
char *name = "홍길동";
int count = strlen(name);
printf("%d", count);  // 6
```

```java
// Java
String name = "홍길동";
System.out.println(name.length());  // 3
```

```python
# Python
name = "홍길동"
print(len(name))  # 3

# 참고
txt = input()  # abcd
txt = list(input())  # ['a', 'b', 'c', 'd']
```

### 문자열 뒤집기

자기 문자열에서 뒤집는 방법이 있고 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있다.

자기 문자열을 이용할 경우는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.

ex) algorithm → 문자열 길이 9, 4회 반복(9 // 2 = 4)

### 문자열 비교

C언어에서는 `strcmp()` 함수를 제공한다.

Java에서는 equals() 메소드를 제공한다. → 문자열 비교에서 `==` 연산은 메모리 참조가 같은지를 물어본다.

Python에서는 `==` 연산자와 `is` 연산자를 제공한다!

```python
# 문자열 비교
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = 'ab'
s5 = s4 + 'c'

print(s1 is s3)  # False
print(s1 == 'abc')  # True
print(s1 is 'abc')  # True
print(s1 == s2)  # True, 같은 모양인가?
print(s1 is s2)  # True, 같은 메모리위치인가?
print(s1 == s5)  # True
print(s1 == s5)  # True
print(s5 == 'ab' + 'c')  # True
print(s5 is 'ab' + 'c')  # False

s1 = 'ab'
s2 = 'ab'
s3 = 'ac'
print(s1 == s2)  # True
print(s1 < s2)  # False
print(s1 < s3)  # True
```

### 문자열 숫자를 정수로 변환하기

C언어에서는 `atoi()` 함수를 제공한다. 역함수로는 `itoa()` 가 있다.

Java에서는 숫자 클래스의 parse 메소드를 제공한다.

*ex)* `Integer.parseInt(String)`, 역함수로는 `toString()` 메소드를 제공한다.

Python에서는 숫자와 문자변환 함수를 제공한다.

*ex)*  `int("123")` , `float(”3.14”)` , `int(’A’, 16)` → 16진수 정수로 변환

*※ 참고 : int()와 같은 atoi()함수 만들기*

```python
def atoi(s):
    i = 0
    for x in s:
        i = i*10 + ord(x) - ord('0')  # 문자열 코드를 정수코드로 변환하는 과정
    return i
```

## 패턴 매칭

패턴 매칭 알고리즘에는 **고지식한 패턴 검색 알고리즘, 카프-라빈 알고리즘, KMP 알고리즘, 보이어-무어 알고리즘** 등이 존재한다.

### 고지식한 알고리즘 (Brute Force)

본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

<aside>

t [ **T** T T T A A C C A ]

i(0) → 일치 → i(1) → 일치 → i(2) → 실패 → i 시작점 1로 이동

p [ **T** T A T T T C T A ]

j(0) → 일치 → j(1) → 일치 → j(2) → 실패

---

t [ T **T** T T A A C C A ]

i(1) → 일치 → i(2) → 일치 → i(3) → 실패 → i 시작점 2로 이동

p [ **T** T A T T T C T A ]

j(0) → 일치 → j(1) → 일치 → j(2) → 실패

---

t [ T T **T** T A A C C A ]

i(2) → 일치 → i(3) → 일치 → i(4) → 일치 → i(5) → 일치 → 실패 → i 시작점 3으로 이동

p [ **T** T A T T T C T A ]

j(0) → 일치 → j(1) → 일치 → j(3) → 일치 → j(4) →실패

---

…

</aside>

```python
def bruteforce(t, p):
    i = j = 0
    N = len(t)
    M = len(p)

    while i < N and j < M:
        if t[i] != p[j]:  # 다르면
            i = i - j + 1  # i - j 비교를 시작했던 위치
            j = 0
        else:  # 같으면
            i += 1
            j += 1

    if j == M:
        return i - j  # 패턴의 시작 인덱스
    else:
        return -1

t = 'TTTTTATTAATA'
p = 'AAA'
print(bruteforce(t, p))  # -1
```

*패턴을 카운트 하는 함수는 아래와 같이 구현해볼 수 있겠다.*

```python
def pattern_count(t, p):
    i = j = 0
    N = len(t)
    M = len(p)

    cnt = 0  # 패턴 횟수 저장 변수

    while i < N and j < M:
        if t[i] != p[j]:  # 다르면
            i = i - j + 1  # i - j 비교를 시작했던 위치
            j = 0
        else:  # 같으면
            i += 1
            j += 1

        if j == M:
            cnt += 1
            i = i - j + 1
            j = 0

    return cnt

t = 'TTTTTATTAATA'
p = 'TTA'
print(pattern_count(t, p))  # 2
```

위와 같은 방법은 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 **O(MN)**이 된다.

길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약 800,000번의 비교가 일어날 것이다.

그럼 비교 횟수를 줄일 수 있는 방법은 없는 걸까?

### KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.

패턴을 전처리하여 배열 `next[M]`을 구해서 잘못된 시작을 최소화한다.

`next[m]` : 불일치가 발생했을 경우 이동할 다음 위치

시간 복잡도는 **O(M+N)**

<aside>

t [ a b c d a b c d … ]

p [ a b c d a b c e f … ]

처음부터 비교하면, t[7], p[7]에서 불일치가 발생한다.

그러면 t[1]에서 검색을 시작하는 것이 아니라,

t와 p의 패턴을 분석하면 ‘abc’가 반복되고 있으므로,

t에서 두 번째 패턴(’abc’)의 시작인 t[4]에서 검색을 다시 시작하는 방식이다.

매칭이 실패했을 때 돌아갈 곳을 계산한다.

t → [ a b c d a b c d … ] → [ -1 0 0 0 0 1 2 3 0 0 ]

*※ 돌아갈 곳을 적는 리스트는 일반적으로 한 칸 더 추가해 놓으면 좋다*.

</aside>

```python
def kmp(t, p):
    N = len(t)
    M = len(p)
    lps = [0] * (M+1)
    # preprocessing
    j = 0 # 일치한 개수== 비교할 패턴 위치
    lps[0] = -1
    for i in range(1, M):
        lps[i] = j          # p[i]이전에 일치한 개수
        if p[i] == p[j]:
            j += 1
        else:
            j = 0
    lps[M] = j
    # search
    i = 0   # 비교할 텍스트 위치
    j = 0   # 비교할 패턴 위치
    while i < N and j <= M:
        if j==-1 or t[i]== p[j]:     # 첫글자자 불일치했거나, 일치하면
            i += 1
            j += 1
        else:               # 불일치
            j = lps[j]
        if j==M:    # 패턴을 찾을 경우
            print(i-M, end = ' ')    # 패턴의 인덱스 출력
            j = lps[j]

    print()
    return
```

### 보이어 무어 알고리즘

오른쪽에서 왼쪽으로 비교, 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘

패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.

<aside>

rithm 문자열의 skip 배열을 만든다.

| m | h | t | i | r | 다른 모든 문자 |
| --- | --- | --- | --- | --- | --- |
| 0 | 1 | 2 | 3 | 4 | 5 |
</aside>

그래서 알고리즘을 비교하자면,

고지식한 패턴 검색 알고리즘 : **O(mn)**

카프-라빈 알고리즘 : **Theta(n)**

KMP 알고리즘 : **Theta(n)**

위의 알고리즘들의 공통점은 텍스트 문자열의 문자를 적어도 한번씩 훑는다는 것이다. 따라서 최선의 경우에도 **Ω(n)**

보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.

최악의 경우에는 **Theta(mn)**이지만, 일반적으로 **Theta(n)**보다 시간이 덜 든다!

## 참고

### 문자열 암호화

**시저 암호 (Caesar cipher)**란,

줄리어스 시저가 사용했다고 하는 암호이다.

알파벳 순서의 시작 키 값을 다르게 하면 구현해볼 수 있다. (최대 25번 검색을 통해 해독 가능)

**문자 변환표**를 이용해서 암호화를 해볼 수 있다. 이 방법은 단일 치환 암호 방식이다.

*단일 치환 암호의 키의 총 수는 매우매우 크다.*

이 암호를 풀기 위해 모든 키를 조사하려면 상당히 많은 시간이 필요할 것이다. *→ 해결 방법을 생각해보자.*

**bit열의 암호화**는 배타적 논리합(exclusive-or, XOR) 연산을 사용한다.

### 문자열 압축

저장소의 크기를 줄이며 정확한 정보를 저장하는 방법이 있을까?

**Run-length encoding 알고리즘**을 적용한다.

<aside>

[ A B B B B B B B B A ]

→ [ A 1 B 8 A 1 ]

</aside>

위의 방법은 이미지 파일 포맷 중 BMP 파일포맷의 압축 방법이다.

좀 더 효율적인 방법으로는 **허프만 코딩 알고리즘**이 있다.