## 프로그래밍과 논리/수학

프로그래밍을 위한 **논리학의 기초**를 학습한다.

아래의 예를 살펴보자.

<aside>

*ex1)*

**D F 3 7**

사실 : 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음

주장 : 만약 한쪽이 D인 경우, 반대쪽은 3이 적혀 있을 것이다.

위 주장이 사실인지, 카드를 직접 뒤집어 보면서 확인하고자 한다.

주장의 참과 거짓을 증명하기 위해, 반드시 뒤집어 봐야 하는 카드는?

→ 답 : [D]와 [7]

→ D를 뒤집었을 때, 3이 안 나오면 거짓을 증명 가능

→ 3을 뒤집었을 때, D가 있더라도 주장이 참임을 확신할 수 없음.

→ 7을 뒤집었을 때, D가 있다면 거짓을 증명할 수 있음.

</aside>

<aside>

*ex2)*

맥주집의 규칙 : 20세 이하인 사람은 맥주를 마실 수 없음.

사실 : 나이 or 마시고 있는 것이 표시되어 있음.

규칙이 잘 지켜지고 있는지 확인하고자 한다면 다음 4명 중, 확인이 필요한 사람은?

**17세 31세 콜라 맥주**

→ 답 : 17세와 맥주

</aside>

맥주집 문제가 더 풀이 쉽게 느껴지겠지만 두 문제는 완전히 같은 문제이다.

→ **논리적 구성은 완전히 동일하다**

만약 맥주집 문제가 더 쉽다고 느껴진다면 맥주집 문제를 풀 때 논리를 사용한 것이 아니다!

### Soft Logic, Hard Logic

맥주집 문제를 풀 때는 직관을 사용한 것

→ 직관은 논리적인 느낌을 주는 것 = **Soft Logic**

직관은 나쁜 게 아니다. → 직관의 장점은 (익숙한 상황에서) 빠르다는 것이다.

직관의 단점은 정확하지 않다는 것 (가끔 익숙한 상황에서도 틀린다.) → 그리고 강한 착각을 일으킨다는 것

직관적인 논리와, 진짜 논리를 구분해야 하는 이유는 무엇일까?

<aside>

*ex1) 자녀의 대화*

아빠 : 너 과자 몇 개 먹었니?

자녀 : 1개요.

아빠 : 3개 먹었네, 왜 거짓말을 했니?

자녀 : 거짓말이 아닙니다. 1개 먹은 것은 사실이거든요.

</aside>

<aside>

*ex2) 친구와 버스 정류장에서*

A : 친구야 나 잔돈이 없다. 너 천 원 있니?

B : 아니, 없어

A : 그럼 난 못 타겠다. 그런데 너 아까 만원 있다고 하지 않았어?

B : 응, 천원이 아니라 난 만원을 가지고 있지.

</aside>

*ex1)* 질문은 정확한 수를 요구하는 것이다. *ex2)* 질문은 액수 이상이 있는지 확인하는 것이다.

진짜 논리가 아닌 직관적인 논리를 사용하면 논리적 오류가 발생하는데,

논리가 약한 사람은, 이것이 잘못되었는지 파악조차 하지 못한다.

<aside>

*ex) 토플과 복권*

“합격하려면 토플 500전 이상 **혹은** 토익 600점 이상이 필요”

→ 둘 중에 하나만 있어도, 둘 다 있어도 합격이라는 뜻. (=Inclusive OR)

“복권에 당첨되면 자동차 **혹은** 천만원을 줍니다.”

→ 둘 중 하나만 준다는 것, 둘 다 준다는 것이 아니다. (=Exclusive OR)

</aside>

일상 생활에서는 Soft Logic이 빠르기 때문에 유용하지만,

프로그래밍은 **Hard Logic**을 사용해야 한다.

→ 직관적인 논리로 프로그래밍을 하면, 프로그램이 동작을 하지 않는다.

→ 프로그래밍 언어의 표현들은, 모두 논리학에서 나온 것이다.

→ 사용되는 많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다.

### 논리 연습

### 증명

<aside>

**명제**

참과 거짓으로 판별할 수 있는 문장

</aside>

증명은 정확한 명제식으로 표현할 수 있는 것이어야 한다.

보통은 정확한 명제식까지 쓰지는 않으나 근본적으로 명제식으로 바꿀 수 있다.

증명에 대한 수많은 오해가 **p→q를 p↔q와 혼동**하는 것에서 일어난다.

<aside>

**p → q (조건 명제)**

p가 참일 때, q도 참이다.

</aside>

<aside>

*ex) “4가 짝수 일때, 4^2도 짝수이다.”* 를 증명해보자.

- **증명하는 방법 3가지**
    1. 대우 증명
        - *4^2이 홀수라면, 4는 홀수이다.*
        - 가정이 거짓 → 무조건 참이다.
        - 대우 명제가 참이므로, 원래 명제도 참이다.
    2. 직접 증명
        - *4가 짝수다 = 4 = (2k)*
        - *4^2 = (2k)^2 = 4(k^2)*
        - *4로 나누어 떨어진다. → 짝수*
    3. 간접 증명 (모순 증명)
        - p → q 에서, q가 거짓이라고 가정하는 것.
        - *4^2이 홀수*라고 가정하자.
        - *4^2 = (4k^2)* → *짝수이다.* → 반대 명제는 모순이 발생!
        - 원래 명제가 참이다.
    4. 진리표 그리기
</aside>

증명식을 세울 때,

**A를 위아래로 뒤집은 모양**은 **“모든 ~에 대해서”** 라는 뜻이다.

**E를 좌우로 뒤집은 모양**은 **“하나라도 만족하는 ~가 있다”** 라는 뜻이다.

…

*Hard Logic을 따지는 것은 어렵다. 많은 연습을 통해 훈련하는 것이 좋겠다.*

## 논리와 증명

<aside>

*ex) 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오.*

**~ ( ~ p ^ q ) v q**

| p | q | ~p | ( ~ p ^ q ) | ( ~ p ^ q ) | ~ ( ~ p ^ q ) v q |
| --- | --- | --- | --- | --- | --- |
| T | T |  |  |  |  |
| T | F |  |  |  |  |
| F | T |  |  |  |  |
| F | F |  |  |  |  |
</aside>

<aside>

*ex) n^2이 3의 배수이면 n은 3의 배수임을 증명해라. (n은 자연수)*

대우 명제를 이용한다.

→ *n이 3의 배수가 아니면, n^2은 3의 배수가 아니다.*

*n = 3k+l or 3k+2*

*n^2 = 9k^2 + 6k + 1 = 3(3k^2+2k) + 1*

*n^2 = 9k^2 + 12k + 4 = 3(3k^2+4k+1) + 1*

→ 3의 배수가 아니다.

→ 대우가 참이므로, 본 명제도 참이다!

</aside>

*논리적인 사고가 알고리즘 설계, 디버깅에 매우 중요하다.*

*수학적으로 증명해야, 알고리즘이 정확하다는 것을 증명할 수 있을 것이다.*

## 수와 표현

컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현한다.

k개의 비트를 사용하면 0부터 2^(k-1)까지 표현 가능하다.

→ 그러나 꼭 이 범위는 아니고, 약속하는 방식에 따라 다르다.

10진수로 k자리를 쓰면 0부터 10^(k-1)까지 표현이 가능한 것과 완전히 동일한 과정이다.

어떤 값 **n**을 표현하기 위해서는 몇 개의 비트가 필요할까?

**2^k - 1 ≥ n**이 성립해야 한다. 즉, 2^k ≥ n+1

같은 의미로, k ≥ log(n+1) **약 log(n) 비트가 필요**하다.

→ 2진수에서 log(n) 비트로 표현할 수 있는 숫자 범위는 n까지가 된다.

<aside>

*ex) x = log_a(yz)일 때 x를 2를 밑으로 하는 로그들로 표현하시오.*

x = log(yz) / log(a) = **(log(y) + log(z)) / *log(a)***

</aside>

*컴퓨터는 데이터를 이진법으로 처리한다.*

*효율적으로 알고리즘을 설계하며, 메모리 관리에 효율적으로 할 수 있다.*

*정수론, 수의 표현 키워드로 학습하면 되겠다.*

## 집합과 조합론

두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.

예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k=2(2k)임을 보이면 되는 것이다.

두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.

### 귀납법과 귀류법

**귀납법**은, 특정 사례부터 출발해서, 일반적인 규칙을 찾는 방법이다.

→ 기저 사례, 귀납 가정, 귀납 단계

**귀류법**은, 어떤 명제가 거짓일 수 없다라고 가정하고 이로 인해 발생하는 모순을 찾는 방식이다.

*많은 데이터 구조들에서 활용되는 개념이며,*

*경우의 수, 해시 , 트리, 경로 탐색 등등에서 사용된다.*

## 기초 수식

알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.

풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다.

<aside>

*ex1) T(n) = T(n-1) + 1, T(0) = 1, 다음 재귀식들을 O notation수준으로 풀어라.*

*= T(n-2) + 1 + 1*

*= T(n-3) + 1 + 1 + 1*

*…*

*= T(n-k) + k*

→ T(0) + k, k=n

→ 1 + k = 1 + n

→ **O(T(n)) = O(n)**

</aside>

<aside>

*ex2) T(n) = T(n-1) + n, T(0) = 1*

*= T(n-2) + (n-1) + n*

*= T(n-3) + (n-2) + (n-1) + n*

*= T(n-k) + (n-(k-1)) + (n-(k-2)) + … + n*

*= T(0) + 1 + 2 + 3 + … + n*

*= 1 + n(n+1)/2* → **O(n^2)**

</aside>

<aside>

*ex3) T(n) = T(n-1) + log(n), T(0) = 1*

*= T(n-2) + log(n-1) + log(n)*

*= T(n-3) + log(n-2) + log(n-1) + log(n)*

*…*

*= T(0) + log0 + log1 + log2 + … + log(n), k = n*

*≤ T(0) + log(n) + log(n) + log(n) + … + log(n)*

*≤ 1 + nlog(n)* → **O(nlog(n))**

</aside>

<aside>

*ex4) T(n) = T(n/2) + 1, T(1) = 1*

*= T(n/2^2) + 1 + 1*

*= T(n/2^3) + 1 + 1 + 1*

*= T(n/2^n) + k*

*= T(1) + k, k = log(n)* → **O(log(n))**

</aside>

*알고리즘의 효율성을 분석 및 최적화를 위해 기초 수식을 사용하고, 매우 중요하다!*

*→ **N값이 몇 번 반복되어야 하는가? 반복마다 연산 횟수가 어떻게 증가하는가?***

## 재귀

재귀 함수는 언제 써야 하는가?

→ N 중 반복문이 필요할 때

→ 큰 문제를 작은 문제로 분할할 수 있을 때

→ 대표적인 재귀 접근 방식 : **분할 정복**

언제 재귀 함수에서 return을 써야 할까?

→ 작은 문제들의 결과를 큰 문제에서 합쳐야 할 때

## 다이나믹 프로그래밍

작은 문제들로 분할해서 푸는 경우가 많은데, 이렇게 되면 중복된 문제들이 많이 발생을 한다.

한 번 계산해 놓은 결과를 저장해두고 저장된 결과를 재활용하여 중복 계산을 피하자.

→ **메모이제이션, 점화식 (Top-down, Bottom-Up)**

*결국, 많은 문제를 풀어보아야 DP가 가능해질 것이다.*