## SW 문제 해결

SW 문제 해결 역량이란,

프로그램을 하기 위한 **많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력**이다.

프로그래머가 사용하는 언어 내 **라이브러리, 자료구조, 알고리즘**에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.

문제 해결 역량은 추상적인 기술이며, 명확히 정의된 실체가 없다.

**무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.**

→ 이를 위해서는 훈련이 필요하다.

<aside>

**문제 해결 과정**

1. 문제를 읽고 **이해**한다.
2. 문제를 익숙한 용어로 **재정의**한다.
3. 어떻게 해결할지 **계획**을 세운다.
4. 계획을 **검증**한다.
5. 프로그램으로 **구현**한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. (**디버깅**)
</aside>

### 문제를 잘 풀기 위한 전략

- 완벽한 문제 이해
- 종이와 펜을 이용한 설계
- 설계 한대로 구현 & 디버깅

## 복잡도 분석

### 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

간단하게 말하면 어떤 문제를 해결하기 위한 절차라고 볼 수 있다.

<aside>

*ex) 책상 앞에서 커피를 마시고 싶다.*

1. 직접 만든다. (가장 효율적인 알고리즘!)
2. 배달을 시킨다.
    
    → 돈 + 배달을 시키는 시간
    
3. 와이프를 시킨다.
    
    → 와이프가 커피를 타와야 하는 이유를 설득. 시간 + 노력 + 수명 등…
    

*~~ㅋㅋㅋㅋㅋㅋㅋㅋ~~*

</aside>

### 알고리즘의 효율

**공간적 효율성**과 **시간적 효율성**을 반영한다.

- **공간적 효율성** : 연산량 대비 얼마나 **적은 메모리 공간**을 요하는 가 (변수, 리스트 길이 등 관련)
- **시간적 효율성** : 연산량 대비 얼마나 **적은 시간**을 요하는 가 (연산 횟수와 관련)

효율성을 뒤집어 표현하면 **복잡도(Complexity)**가 된다. 복잡도가 높을수록 효율성은 저하된다.

### 복잡도의 점근적 표기

시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.

이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)를 사용한다.

입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.

- **Big-Oh 표기법 : 최악의 경우**
- Big-Omega  표기법 : 최선의 경우
- Big-Theta 표기법 : 평균적인 경우

### O(Big-Oh) 표기

**복잡도의 점근적 상한**을 나타낸다.

복잡도가 f(n)=2n^2-7n+4 이라면, f(n)의 O-표기는 O(n^2)이다.

→ 표기법에서는 **최고차항**만을 남긴다. 계수는 버리고 표기한다.

단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 된다.

그러나,

빅오표기법을 **O(5n)** 이렇게 표현하기도 한다.

이 때는 5 배수를 강조해서 표현하고 싶을 때 이렇게 쓰기도 한다.

*논문을 쓸 때 주로 이용된다.*

<aside>

- **자주 사용하는 O-표기**

| Big-O | **내용** |
| --- | --- |
| O(1) | 상수 시간 (Constant time) |
| O(logn) | 로그(대수) 시간 (Logarithmic time) |
| O(n) | 선형 시간 (Linear time) |
| O(nlogn) | 로그 선형 시간 (Log-linear time) |
| O(n^2) | 제곱 시간 (Quadratic time) |
| O(n^3) | 세제곱 시간 (Cubic time) |
</aside>

**알고리즘에서 log의 밑수는 10이 아니라 2이다.**

O(logN) 은 O(1) 보다는 느리지만, 유사한 성능을 보인다.

O(NlogN)은 O(N) 보다는 느리지만, 유사한 성능을 보인다.

### 왜 효율적인 알고리즘이 필요한가

10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면 O(nlogn) 알고리즘은 5분 만에 정렬한다.

효율적인 알고리즘은 슈퍼컴퓨터보다 큰 가치가 있으며,

값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

*코딩테스트에서 사용하는 시간 복잡도는 개발과는 연관이 조금 멀다.*

*이제부터 코딩테스트에서 제한 시간도 고려해봐야 할 것이다.*

<aside>

python은 참고로 **1초 당 3,000만 번 ~ 4,000만 번 연산이 가능**하다.

*ex) N의 범위가 10,000일 때,*

**N^2**( = 1억 번)은 파이썬 기준으로 **3초 이상**이 걸리는 반면,

**NlogN**( = 130,00 ~ 140,000)은 걸리는 **시간이 넉넉하다.**

*ex) 시간 제한이 1초인 경우, 숫자 10,000개를 정렬해라.*

버블 정렬을 이용한다면, 시간 복잡도는 **O(n^2)** 이므로,

**3초 이상이 걸리므로 시간 초과**이다.

카운팅 정렬을 이용한다면, 시간 복잡도는 **O(N+K)** 이므로,

상황에 따라 **시간 제한이 걸릴 수도, 걸리지 않을 수도** 있다.

</aside>

*메모리 공간 제한도 중요하다.*

python에서 자료형 사이즈는 `getsizeof` 를 이용하면 된다.

## 표준 입출력

콘솔 입력 대신, 파일 입력으로 입력을 받아보자.

```python
import sys
# stdin: standard input (표준 입력)
#   open("input.txt", "r")
#       input.txt file 을 읽기 모드로 열겠다.
#       "r" : 읽기 모드
# 테스트케이스를 수정하면서
#   디버깅이 가능하다!
sys.stdin = open("input.txt", "r")  # input.txt 내용 : 10 20
sys.stdout = open("output.txt", "w")  # 결과가 output.txt에 작성됨.

a, b = map(int, input().split())
print(a, b)  # 10 20
```

*코드를 제출할 때는 파일을 입력하는 코드를 주석처리하고 제출한다.*

- **예제** : 두 수를 input.txt파일에서 입력 받고, 두 수의 합과 곱을 output.txt 파일에 출력한다.
    
    ```python
    import sys
    sys.stdin = open("input.txt", "r")
    sys.stdout = open("output.txt", "w")
    
    text = list(map(int, input().split()))
    print(text[0]*text[1])
    ```
    

## 진수 (진법)

<aside>

**10진수** : 사람이 사용하는 진수, 수 하나를 0~9로 표현 (DEC)

**2진수** : 컴퓨터 사용하는 진수, 수 하나를 0과 1로 표현 (BIN)

*8진수 : 2진수를 더 가독성 있게 사용 (OCT)*

**16진수** : 2진수를 더 가독성 있게 사용, 수 하나를 0~9, A~F로 표현 (HEX)

</aside>

왜 16진수를 사용할까?

2진수를 사람이 이해하기 편하도록, **10진수로 변환 시에 연산이 오래 걸린다.**

**16진수로 변환 시에 연산 속도가 매우 빠르다.**

### 진법 변환

10진수를 타 진수로 변환하려면,

원하는 타진 법의 수로 나눈 뒤 나머지를 거꾸로 읽으면 된다.

<aside>

*ex) 149를 타진법으로*

149 % 2 = 1

74 % 2 = 0

37 % 2 = 1

18 % 2 = 0

9 % 2 = 1

4 % 2 = 0

2 % 2 = 0

1

아래에서 위로 읽는다. → **(149)_10 = (10010101)_2 = (225)_8 = (95)_16**

</aside>

진수 변경을 코드로 구현하면 아래와 같다.

*사실 내장 함수를 이용하면 다음과 같이 간단하게 할 수 있다.*

```python
target = 74

print(bin(74))  # 0b로 시작 - 이진법
print(hex(74))  # 0x로 시작 - 16진법
print(oct(74))  # 0o로 시작 - 8진법
```

위에 제시된 내장 함수를 사용하지 않고 코드로 구현해보자.

- **2진수 ↔ 10진수**
    
    ```python
    target = 74
    
    def dec_to_binary(target):
        binary_number = ""
    
        while target > 0:
            remain = target % 2     # 2로 나눈 나머지
            binary_number = str(remain) + binary_number
            target = target // 2    # 2로 나눈다.
    
        return binary_number
    
    def binary_to_decimal(binary_str):
        decimal_number = 0
        pow = 0
    
        for digit in reversed(binary_str):
            if digit == '1':
                decimal_number += 2**pow
            pow += 1
    
        print(decimal_number)
    
    print(dec_to_binary(target))    # 1001010
    binary_to_decimal(dec_to_binary(target))    # 74
    ```
    
- **2진수 ↔ 16진수**
    
    ```python
    target = 74
    
    def decimal_to_hexadecimal(target):
        hex_digit = "0123456789ABCDEF"
        hex_number = ""
        # hex_digit[10] => A
        # hex_digit[15] => F
    
        while target > 0:
            remain = target % 16
            hex_number = hex_digit[remain] + hex_number
            target //= 16
    
        print(hex_number)
    
    decimal_to_hexadecimal(target)  # 4A
    ```