# 1. ALU와 제어장치

CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치이다.

CPU 내부의 모습은 아래와 같다.

- **ALU** : 계산을 담당
- **제어장치** : 명령어를 읽어 들이고 해석하는 것을 담당
- **레지스터** : 작은 임시 저장 장치

이번 절에서는 ALU와 제어 장치에 대해 알아본다.

회로나 구현 방법은 알아보지 않고, ALU와 제어장치가 받아들이고 내보내는 정보를 기준으로 역할에 대해 배운다.

## ALU

ALU가 어떤 정보를 받아들이고 내보내는지 아래와 같이 표현해볼 수 있겠다.

<aside>

레지스터 (**피연산자**)⇒ ALU

제어장치 (**제어신호**)⇒ ALU

ALU (**플래그**)⇒ 플래그 레지스터

ALU (**결괏값**)⇒ 레지스터

</aside>

- **ALU가 받아들이는 정보 :  피연산자, 제어신호**
    
    ALU는 계산하는 부품이라고 했다. 그럼 계산을 하기 위해 무엇이 필요할까?
    
    → **피연산자**와 **수행할 연산**이 필요하다.
    
    → **레지스터를 통해 피연산자를** 받아들이고, **제어장치로부터 제어 신호를** 받아들인다.
    
    → ALU는 이를 바탕으로 산술 연산, 논리 연산 등 다양한 연산을 수행한다.
    
- **ALU가 내보내는 정보 : 결괏값, 플래그**
    
    연산을 수행한 결과는 특정 숫자나 문자, 메모리 주소가 될 수도 있다.
    
    이 **결괏값은 일시적으로 레지스터에 저장**된다.
    
    CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리다.
    
    → ALU가 연산할 때마다 결과를 메모리에 저장한다면 CPU는 메모리에 자주 접근하게 된다.
    
    → 이는 CPU가 프로그램 실행 속도를 늦출 수 있게 된다.
    
    → 그러므로 ALU의 결괏값을 레지스터에 우선 저장하는 것이다.
    
    ALU에서 내보내는 정보 중 **플래그**라는 것이 존재한다.
    
    → 우리는 이 플래그를 [02. 데이터](https://www.notion.so/02-1967900d53b680e5a9ced383a14ac139?pvs=21) 에서 *“음수인지 양수인지 판별하기 위해 플래그를 사용한다”* 라는 내용에서 한 번 보았다.
    
    → 이처럼, ALU는 결괏값뿐만 아니라 연산 결과에 대한 **추가적인 정보**를 내보내야 할 때가 있다.
    
    → 음수를 나타내는 플래그 외에, 연산 결과가 연산 결과를 담을 레지스터보다 클 때 ‘결괏값이 너무 크다’라는 추가 정보를 내보내기도 한다. (이러한 현상을 **overflow**라고 한다.)
    

### 플래그

추가적인 상태 정보를 **플래그**라고 하며, 대표적인 플래그는 아래와 같다.

| **플래그 종류** | **의미** | **사용 예시 (계산 및 연산 결과)** |
| --- | --- | --- |
| 부호 플래그 | 연산한 결과의 부호를 나타냄. | 1은 음수, 0은 양수를 뜻함. |
| 제로 플래그 | 연산 결과가 0인지 여부를 나타냄. | 1은 0이 맞음, 0은 0이 아님. |
| 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지를 나타냄. | 1은 올림수나 빌림수가 발생,
0은 발생하지 않았음. |
| 오버플로우 플래그 | 오버플로우가 발생했는지를 나타냄. | 1은 오버플로우 발생,
0은 발생하지 않았음. |
| 인터럽트 플래그 | 인터럽트가 가능한지를 나타냄. | 1은 인터럽트 가능, 0은 불가능. |
| 슈퍼바이저 플래그 | 커널 모드 or 사용자 모드 실행 중임을 나타냄. | 1은 커널 모드로 실행 중,
0은 사용자 모드로 실행 중 |

CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 추가적, 참고 정보이다.

이러한 플래그들은 **플래그 레지스터**에 저장된다.

이 밖에도 ALU 내부에는 여러 계산을 위한 회로들이 있다.

덧셈을 위한 **가산기**, 뺄셈을 위한 **보수기**, 시프트 연산을 수행해주는 **시프터**, 오버플로우를 대비한 **오버플로우 검출기** 등이 있다.

이 책에서는 회로를 다루지 않으므로, 따로 조사를 해보는 것이 좋겠다.

- **❓ ALU 계산기 종류 및 회로**
    
    <aside>
    
    - **반가산기 (Half Adder) - Carry In 존재X**
        
        → XOR 게이트 + AND 게이트로 덧셈 수행
        
    - **전가산기 (Full Adder) - Carry In 존재O**
        
        → 두 개의 XOR + AND + OR 게이트로 자리 올림까지 계산
        
    - **4비트 가산기 (Ripple Carry Adder)**
        
        → 여러 개의 전가산기를 연결해 다중 비트 연산 수행
        
    - **논리 연산 회로 (AND, OR, XOR 등)**
        
        → 기본 논리 게이트로 연산 처리
        
    - **시프트 회로 (Shift Register)**
        
        → 데이터를 왼쪽/오른쪽으로 이동시키는 회로
        
    - **비교 회로 (Comparator)**
        
        → 두 수가 같은지 비교하는 XOR/AND 기반 회로
        
    </aside>
    
- ❓ **가산기 종류**
    
    <aside>
    
    - **반가산기(Half Adder) 사용처**
        
        1비트 덧셈만 필요한 곳
        
        자리올림을 고려하지 않아도 되는 간단한 회로
        
        하드웨어 구조 단순 & 저전력 설계가 필요한 경우
        
    
    💡 **예제**
    
    ✔ **LSB(가장 낮은 자리, 최하위 비트) 연산** → 자리올림이 필요 없어서 반가산기로 처리
    
    ✔ **패리티 검사(오류 검출 회로)** → XOR 연산이 핵심이라 반가산기 활용
    
    ✔ **간단한 논리 회로** → 논리 게이트 몇 개로 구현 가능
    
    - **전가산기(Full Adder) 사용처**
        
        여러 비트 연산(멀티비트 덧셈)에서 필수!
        
        자리올림을 고려해야 하는 경우
        
        더 복잡한 연산(가산기, ALU, 프로세서 설계 등)에 활용
        
    
    💡 **예제**
    
    ✔ **다중 비트 덧셈기(4비트, 8비트 가산기)** → 자리올림을 처리해야 해서 전가산기 필수
    
    ✔ **CPU의 ALU(Arithmetic Logic Unit) 회로** → 덧셈, 뺄셈, 연산 처리에 전가산기 사용
    
    ✔ **디지털 계산기, 신호처리 하드웨어** → 자리올림을 반영해야 정확한 연산 가능
    
    </aside>
    

## 제어장치

**제어장치**는 제어 신호를 내보내고, 명령어를 해석하는 부품이다.

**제어 신호**는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

제어장치는 CPU의 구성 요소 중 가장 정교하게 설계된 부품이라고 할 수 있다.

CPU 제조사마다 제어장치의 구현 방식이나 명령어를 해석하는 방식, 받고 내보내는 정보에는 차이가 조금씩 있다.

제어장치의 역할을 이해하는 데에만 초점을 맞춰보자.

<aside>

플래그 레지스터 (**플래그**)⇒ 제어장치

명령어 레지스터 (**해석할 명령어**)⇒ 제어장치

(**클럭**)⇒ 제어장치

제어장치 (**제어 신호 To. 레지스터, ALU**)⇒ CPU 내부

제어장치 (**제어 신호 To. 메모리, 입출력장치**)⇒ CPU 외부(제어 버스)

제어 버스 (**제어 신호**)⇒ 제어장치

</aside>

### 제어장치가 받아들이는 정보들

**클럭 신호, 해석해야 할 명령어, 플래그 값, 제어 버스로 전달된 제어 신호**

1. 제어장치는 **클럭 신호**를 받아들인다
    
    <aside>
    
    **클럭 (Clock)**
    
    컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위이다.
    
    </aside>
    
    주기에 맞춰 레지스터끼리 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령을 읽어들이는 것이다.
    
    → 이 말을 “컴퓨터의 모든 부품이 한 클럭마다 작동한다.”라고 이해하면 안된다.
    
    → **컴퓨터 부품들은 클럭에 맞춰 작동할 뿐 한 박자마다 작동하는 것은 아니다.**
    
    → **여러 클럭에 걸쳐 실행**될 수 있다.
    

![image.png](attachment:31a0f448-e6bb-4bfb-ae30-7033d2045b7f:image.png)

1. 제어장치는 **‘해석해야 할 명령어’**를 받아들인다
    
    **명령어 레지스터**에 CPU가 해석해야 할 명령어가 저장된다.
    
    제어장치는 이 명령어 레지스터로부터 해석할 **명령어를 받아들이고 해석**한 뒤, **제어 신호를 발생**시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.
    

1. 제어장치는 **플래그 레지스터 속 플래그 값**을 받아들인다
    
    제어장치는 ALU 연산에 대한 추가적인 상태인 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.
    

1. 제어장치는 **제어 버스로 전달된 제어 신호**를 받아들인다
    
    입출력장치를 비롯한 CPU 외부 장치도 제어 신호를 발생시킬 수 있다. 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들인다.
    

### 제어장치가 내보내는 정보들

크게 CPU **외부에 전달**, CPU **내부에 전달**하는 제어 신호가 있다.

1. **외부**에 전달하는 제어 신호
    
    CPU외부에 제어 신호를 전달한다 = 제어 버스로 제어 신호를 내보낸다.
    
    크게 **메모리에 전달**하는 제어 신호, **입출력장치에 전달**하는 제어 신호가 있다.
    
    - 제어장치가 메모리에 저장된 값을 읽거나 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보낸다.
    - 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때는 입출력장치로 제어 신호를 내보낸다.

1. **내부**에 전달하는 제어 신호
    
    크게 **ALU에 전달**하는 제어 신호, **레지스터에 전달**하는 제어 신호가 있다.
    
    - 수행할 연산을 지시하기 위해 ALU로 제어 신호를 내보낸다.
    - 레지스터 간에 데이터를 이동시키거나 저장된 명령어를 해석하기 위해 레지스터로 제어 신호를 내보낸다.

# 2. 레지스터

프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다.

→ **레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있다.**

각 레지스터의 이름과 역할에 집중해본다.

## 반드시 알아야 할 레지스터

**프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 범용 레지스터, 플래그 레지스터, 스택 포인터, 베이스 레지스터**

CPU마다 레지스터 종류가 다르다. 이들은 각 CPU 제조사 홈페이지에서 확인해볼 수 있다.

여기에서는 많은 CPU가 공통으로 포함하고 있는 레지스터를 학습해본다.

- **프로그램 카운터(Program Counter)**
    
    **메모리에서 가져올 명령어의 주소, 메모리에서 읽어 들일 명령어의 주소**를 저장한다.
    
    **명령어 포인터**(Instruction Pointer)라고 부르는 CPU도 있다.
    

- **명령어 레지스터(Instruction Register)**
    
    **해석할 명령어, 방금 메모리에서 읽어 들인 명령어**를 저장하는 레지스터.
    
    제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤 제어 신호를 내보낸다.
    

- **메모리 주소 레지스터(MAR; Memory Address Register)**
    
    **메모리의 주소**를 저장하는 레지스터
    
    CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.
    

- **메모리 버퍼 레지스터(MBR; Memory Buffer Register)**
    
    **메모리와 주고받을 값(데이터와 명령어)**을 저장하는 레지스터
    
    **메모리 데이터 레지스터(MDR; Memory Data Register)**라고도 부른다.
    
    CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거친다.
    

- 위의 레지스터들은 어떻게 작동될까. 가상의 상황을 적용해보자.
    
    <aside>
    
    1. **메모리**가  아래와 같이 저장되어 있다고 가정한다.
        
        실행할 프로그램이 1000번지부터 1500번지까지 저장되어 있다.
        
        | **실행할 프로그램** | **주소** |
        | --- | --- |
        | 1101 | 1000번지 |
        | 1111 | 1001번지 |
        | … | … |
        | 1000 | 1500번지 |
        
        프로그램을 이루는 명령어들은 각각 하나의 메모리 번지를 차지하고 있다.
        
    2. 프로그램을 처음부터 실행하기 위해 **프로그램 카운터**는 1000이 저장된다.
        
        메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미한다.
        
    3. 1000번지를 읽어 들이기 위해서 **주소 버스**로 1000번지를 내보내야 한다.
        
        이를 위해 **메모리 주소 레지스터**에 1000이 저장된다.
        
    4. **‘메모리 읽기’ 제어 신호**와 **메모리 주소 레지스터** 값이 각각 **제어 버스**와 **주소 버스**를 통해 **메모리**로 보내진다.
    5. 메모리 1000번지에 저장된 값은 **데이터 버스**를 통해 **메모리 버퍼 레지스터**로 전달되고, **프로그램 카운터**는 증가 되어 다음 명령어를 읽어 들일 준비를 한다.
    6. **메모리 버퍼 레지스터**에 저장된 값은 **명령어 레지스터**로 이동한다.
    7. **제어 장치**는 **명령어 레지스터**의 명령어를 해석하고 **제어 신호**를 발생시킨다.
    </aside>
    
    위의 예를 보면, 5단계에서 프로그램 카운터 값이 증가한다.
    
    → 1000번지 명령어 처리가 끝나면 CPU는 다음 명령어(1001번지)를 읽어 들인다.
    
    → **프로그램 카운터**는 지속적으로 증가하며, 다음 명령어를 읽을 준비를 한다.
    
    → CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행할 수 있는 이유가 된다.
    
    ### 순차적인 실행 흐름이 끊기는 이유
    
    프로그램 카운터는 꾸준히 증가하며 프로그램을 차례대로 실행한다.
    
    그러나 명령어의 다음 번지 주소가 아닌 전혀 다른 값으로 업데이트 되는 경우가 있다.
    
    명령어 중 `JUMP` , `CONDITIONAL JUMP` , `CALL` , `RET` 와 같이 **특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행**되었을 때 프로그램은 차례대로 실행되지 않는다.
    
    → 1200번지를 실행하는 도중 JUMP 2500이라는 명령어를 만났다면, 1201번지가 아닌 2500번지를 실행해야 하기 때문에 프로그램 카운터에는 2500번지가 저장된다.
    
    **인터럽트**가 발생해도 프로그램의 순차적인 실행 흐름이 끊어지기도 한다.
    

- **범용 레지스터(General Purpose Register)**
    
    다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터.
    
    **데이터와 주소를 모두 저장**할 수 있다. 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 존재한다.
    

- **플래그 레지스터(Flag Register)**
    
    **연산 결과 또는 CPU 상태에 대한 부가적인 정보**를 저장하는 레지스터.
    

## 특정 레지스터를 이용한 주소 지정 방식

프로그램 카운터, 스택 포인터, 베이스 레지스터는 주소 지정에 사용될 수 있는 특별한 레지스터이다.

**스택 포인터**는 **스택 주소 지정 방식**,

**프로그램 카운터와 베이스 레지스터**는 **변위 주소 지정 방식**에 사용된다.

### 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식.

스택은 LIFO 방식이며, **스택 포인터**는 **스택의 꼭대기를 가리키는 레지스터**이다.

데이터를 꺼내거나 추가할 때, 스택 포인터(스택의 꼭대기 주소)는 바뀐다.

 

이 스택이라는 것은 어디에 존재하는가? → 메모리 안에 있다.

→ 정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있다. (**스택 영역**)

→ 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이 존재함.

### 변위 주소 지정 방식

명령어는 연산 코드와 오퍼랜드로 이루어져 있다. ([03. 명령어](https://www.notion.so/03-1a47900d53b6803c9d4ffa8c5a9ad41b?pvs=21))

오퍼랜드 필드에는 메모리의 주소가 담길 때도 있다.

**오퍼랜드 필드의 값(변위)**과 **특정 레지스터의 값을 더하여** 유효 주소를 얻어내는 주소 방식이 **변위 주소 지정 방식**이다.

이 방식을 사용하는 명령어는 **연산 코드 필드, 레지스터 필드, 오퍼랜드 필드**가 있다.

| **연산코드** | **레지스터** | **오퍼랜드** |
| --- | --- | --- |
| 이런 내용을 수행해라 | 이 레지스터 값과 | 이 주소를 더한 곳에 있는 데이터로 |

변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라

**상대 주소 지정 방식**, **베이스 레지스터 주소 지정 방식** 등으로 나뉜다.

→ 대표적인 변위 주소 지정 방식

- **상대 주소 지정 방식**
    
    **오퍼랜드**와 **프로그램 카운터**의 값을 더하여 유효 주소를 얻는 방식
    
    프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있음.
    
    <aside>
    
    *ex)* *만약 오퍼랜드가 -3이었다면*
    
    CPU는 읽어 들이기로 한 명령어로부터 세 번째 이전 번지로 접근한다.
    
    → 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행.
    
    *ex) 만약 오퍼랜드가 3이었다면*
    
    CPU는 읽어 들이기로 한 명령어로부터 세 번째 이후 번지로 접근한다.
    
    → 실행하려는 명령어에서 세 칸 건너뛴 명령어를 실행.
    
    </aside>
    
    즉, 상대 주소 지정 방식은 모든 코드를 실행하는 것이 아닌,
    
    if문처럼 분기하여 **특정 주소의 코드를 실행할 때 사용**된다.
    
- **베이스 레지스터 주소 지정 방식**
    
    **오퍼랜드**와 **베이스 레지스터**의 값을 더하여 유효 주소를 얻는 방식.
    
    **베이스 레지스터**는 **기준 주소**, **오퍼랜드**는 **기준 주소로부터 떨어진 거리**로서의 역할을 한다.
    
    → 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지 연산한다.
    
    <aside>
    
    *ex) 베이스 레지스터에 200, 오퍼랜드가 40이라면*
    
    → 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하는 것을 의미
    
    *ex) 베이스 레지스터에 550, 오퍼랜드가 50이라면*
    
    → 기준 주소 550번지로부터 50만큼 떨어진 600번지로 접근하는 것을 의미
    
    </aside>
    

### 상용화된 CPU 속 레지스터 및 주소 지정 방식

실제 CPU의 작동 법을 관찰하면, 현재까지 배운 내용과 전혀 다른 모습을 할 수도 있다.

대부분 레지스터 이름이 달라 이런 문제가 발생한다. CPU 제조사마다 레지스터 이름, 역할이 다르다.

→ R1, R2, R3 … EAX, EBX … 등 천차만별이다.

실제 CPU의 작동법을 자세히 관찰하고 분석하길 원하면 상용화된 CPU 속 레지스터를 들여다볼 필요가 있다.

- ❓ 가장 대중적인 CPU인 **x86, ARM 레지스터**
    
    [GitHub - kangtegong/self-learning-cs: 『혼자 공부하는 컴퓨터구조 & 운영체제』 (한빛미디어)](https://github.com/kangtegong/self-learning-cs)
    
    <aside>
    
    ### 🏭 **ARM CPU를 만드는 대표적인 회사들**
    
    ✅ **애플** → A시리즈 (아이폰, 아이패드) / M시리즈 (맥)
    
    ✅ **퀄컴** → 스냅드래곤 (갤럭시, 안드로이드 폰)
    
    ✅ **삼성** → 엑시노스
    
    ✅ **미디어텍** → Dimensity, Helio
    
    ✅ **NVIDIA** → Tegra (닌텐도 스위치 같은 곳)
    
    ✅ **브로드컴** → 라즈베리파이 CPU
    
    → 모바일용, 저전력용 (배터리 효율 높음)
    
    </aside>
    
    <aside>
    
    ### 🏢 **x86 CPU 대표적인 제조사**
    
    ✅ **인텔 (Intel)** → 코어 i3/i5/i7/i9, 펜티엄, 제온 등
    
    ✅ **AMD** → 라이젠 (Ryzen), 스레드리퍼 (Threadripper), 에픽 (EPYC)
    
    → PC, 서버용 (강력한 성능)
    
    → 연산을 하는 레지스터 존재함.
    
    </aside>
    

# 3. 명령어 사이클과 인터럽트

CPU가 하나의 명령어를 처리하는 과정에는 정해진 흐름이 있고, 그 흐름을 반복하며 명령어들을 처리해 나간다.

하나의 명령어를 처리하는 정형화된 흐름을 **명령어 사이클** 이라고 한다.

CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 끊어지는 상황이 발생하는데,

이를 **인터럽트**라고 한다.

## 명령어 사이클

**인출 사이클**, **실행 사이클**, **간접 사이클**

프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행된다. → **명령어 사이클**이 반복된다.

메모리에 저장된 명령어 하나를 실행한다고 가정해보자. → 아래의 예시를 참고한다.

[위의 레지스터들은 어떻게 작동될까. 가상의 상황을 적용해보자.](https://www.notion.so/1ad7900d53b68038a6c7ca4ce22e4f64?pvs=21) 

- 가장 먼저 무엇을 해야 하나?
    
    → 명령어를 메모리에서 CPU로 가져와야 한다.
    
    → 이 단계를 **인출 사이클(fetch cycle)**이라고 한다.
    
    → 예시의 2단계 ~ 6단계가 **인출 사이클** 과정이라고 볼 수 있다.
    
- CPU로 가져온 명령어를 실행해야 한다.
    
    → 이 단계를 **실행 사이클(execution cycle)**이라고 한다.
    

프로그램을 이루는 명령어는 일반적으로 이 둘의 사이클을 반복하며 실행된다.

하지만, 모든 명령어가 이렇게 간단히 실행되는 건 아니다.

[03. 명령어](https://www.notion.so/03-1a47900d53b6803c9d4ffa8c5a9ad41b?pvs=21) 에서 배운 **간접 주소 지정 방식**에서,

오퍼랜드 필드에 유효 주소의 주소를 명시한다고 했다.

→ 인출 사이클 후에 바로 실행 사이클에 돌입할 수 없다.

→ 명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 된다.

→ 이 단계를 **간접 사이클(indirect cycle)**이라고 한다.

그러나,

명령어 사이클은 이게 끝이 아니다.

## 인터럽트

‘방해하다, 중단시키다’.

CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있다.

→ 이렇게 작업을 방해하는 신호를 **인터럽트(Interrupt)** 라고 한다.

CPU가 작업을 잠시 중단해야 할 정도면,

‘CPU가 꼭 주목해야 할 때’, ‘CPU가 얼른 처리해야 할 다른 작업이 생겼을 때’

일 것이다.

- **동기 인터럽트(synchronous Interrupts)**
    
    CPU에 의해 발생하는 인터럽트.
    
    CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때,
    
    (프로그래밍 상의 오류와 같은 예외적인 상황에 마주쳤을 때)
    
    발생하는 인터럽트를 뜻한다. → **예외(Exception)**라고 부른다.
    
    [참고 : 예외](https://www.notion.so/1ae7900d53b680eeb9e7d75f004eec0c?pvs=21) 
    
- **비동기 인터럽트(asynchronous Interrupts)**
    
    입출력장치에 의해 발생하는 인터럽트.
    
    세탁기 완료 알림, 전자레인지 조리 완료 알림 등과 같이 알림 역할을 한다.
    
    <aside>
    
    *ex) CPU가 프린터에 입출력 작업을 부탁했을 때*
    
    프린터 작업이 끝나면 CPU에 완료 알림(인터럽트)을 보낸다.
    
    *ex) 키보드, 마우스가 입력을 받아들였을 때*
    
    이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보낸다.
    
    </aside>
    
    → 이 책에서는 **하드웨어 인터럽트** 라고 부른다.
    

### 하드웨어 인터럽트

알림과 같은 인터럽트. CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이 인터럽트를 사용한다.

<aside>

*ex) CPU가 프린터에 출력을 명령했다.*

입출력장치는 CPU보다 속도가 느리다.

→ 입출력 작업의 결과를 바로 받아볼 수 없다.

→ 하드웨어 인터럽트를 사용하지 않는다면 CPU는 주기적으로 프린터의 완료 여부를 확인해야 한다. 이는 사이클 낭비가 된다.

→ 그러므로 CPU는 프린터로부터 완료 인터럽트를 받을 때까지 다른 작업을 처리한다.

</aside>

### 하드웨어 인터럽트 처리 순서 (중요❗)

<aside>

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4. 에서 백업해 둔 작업을 복구하여 실행을 재개한다.
</aside>

- **인터럽트 요청 신호**
    
    인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트 하기 전에는 끼어들어도 되는지 CPU에 물어봐야 한다.
    
    → 이것이 인터럽트 요청 신호
    
- **인터럽트 플래그**
    
    CPU가 인터럽트 요청을 수용하기 위해 플래그 레지스터에서 활성화 되는 플래그.
    
    → 하드웨어 인터럽트를 받아들일지, 무시할지 결정함.
    
    → CPU가 중요한 작업을 처리해야 하거나, 어떤 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정된다. (비활성화 시, 인터럽트 무시 가능)
    
    - **❓ 인터럽트 플래그 비트**
        
        <aside>
        
        **1**이면 마스크 되지 않은 인터럽트 수락,
        
        **0**이면 마스크 되지 않은 인터럽트 거절을 뜻한다.
        
        마스크 된 인터럽트는 아래에 제시.
        
        </aside>
        
    
    그러나,
    
    모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다!
    
    → 무시할 수 없는 인터럽트 요청도 있다. 반드시 가장 먼저 처리해야 하는 인터럽트가 존재한다는 것이다. *ex) 정전, 하드웨어 고장 등*
    
    - **❓ 무시할 수 없는 인터럽트**
        
        <aside>
        
        - **NMI (Non-Maskable Interrupt)**
            
            인터럽트 비활성화로 막을 수 없음.
            
            *ex) 하드웨어 오류(메모리 오류, 전원 이상), 시스템 크래시 감지, 긴급 데이터 백업이 필요할 때*
            
        </aside>
        
    
- **인터럽트 서비스 루틴 (= 인터럽트 핸들러)**
    
    CPU가 인터럽트 요청을 받아들인다면, 처리하기 위한 프로그램.
    
    해당 인터럽트를 어떻게 처리하고 작동해야 할 지에 대한 정보로 이루어져 있다.
    
    다른 프로그램과 마찬가지로 **명령어와 데이터**로 이루어져 있다.
    
    → 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행된다.
    
    <aside>
    
    *ex)*
    
    *키보드가 어떤 인터럽트 요청을 보냈을 때 어떻게 작동한다.*
    
    *마우스가 어떤 인터럽트 요청을 보냈을 때는 어떻게 작동한다.*
    
    *…*
    
    </aside>
    

즉,

CPU가 인터럽트를 처리한다.

= **인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다.**

<aside>

1. 정상 작업 진행
2. 인터럽트 발생
3. 인터럽트 서비스 루틴으로 점프
4. 인터럽트 서비스 루틴 실행
5. 기존 작업으로 점프
6. 기존 작업 수행 재개
</aside>

각 입출력장치마다 다른 인터럽트 서비스 루틴을 가진다.

→ 메모리에는 여러 개의 인터럽트 서비스 루틴이 저장되어 있다.

- **인터럽트 벡터**
    
    수많은 인터럽트 서비스 루틴을 구분하기 위해 사용된다.
    
    인터럽트 서비스 루틴의 시작 주소를 알 수 있다.
    
    ※ CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 **데이터 버스**를 통해 **인터럽트 벡터**를 전달받는다.
    

인터럽트가 발생하기 전까지 레지스터에 저장되어 있었던 값들은, 인터럽트 서비스 루틴이 끝나면 되돌아와서 수행을 해야 하기 때문에 백업이 필요하다.

→ 인터럽트 서비스 루틴을 실행하기 전에 현재 프로그램을 재개하기 위해 필요한 모든 내용을 **스택에 백업**한다.

→ 그런 다음 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 실행한다.

→ 인터럽트를 처리하면, 스택에 저장해 둔 값을 불러와 이전에 수행하던 작업을 재개한다.

정리하자면, CPU는 아래와 같은 과정을 반복해 나가며 프로그램을 실행한다.

![image.png](attachment:58a7bb88-b4b0-40d0-ab91-a6844baaf455:image.png)

### 참고 : 예외

- **폴트(Fault)**
    
    예외를 처리한 직후 **예외가 발생한 명령어**부터 실행을 재개
    
    <aside>
    
    *ex) 명령어를 실행하기 위해 꼭 필요한 데이터가 보조기억장치에 있을 때*
    
    프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.
    
    → CPU는 폴트를 발생시키고 보조기억장치로부터 필요한 데이터를 메모리로 가져온다.
    
    → 실행을 재개하면, CPU는 폴트가 발생한 그 명령어부터 실행한다.
    
    </aside>
    

- **트랩(trap)**
    
    예외를 처리한 직후 **예외가 발생한 명령어의 다음 명령어**부터 실행을 재개
    
    <aside>
    
    *ex) 디버깅*
    
    특정 코드가 실행되는 순간 프로그램의 실행을 멈추게 할 수 있음.
    
    → 트랩을 처리하면(특정 코드에서 디버깅이 끝나면), 다음 명령어부터 실행을 이어 나감.
    
    </aside>
    

- **중단(abort)**
    
    실행 중인 프로그램을 **강제로 중단**시킬 수밖에 없는 심각한 오류를 발견했을 때 발생.
    

- **소프트웨어 인터럽트**
    
    시스템 호출이 발생했을 때 → 9장에서 나올 예정…
    
    - **❓ 소프트웨어 인터럽트가 뭔데?**
        
        <aside>
        
         CPU가 실행 중인 프로그램의 흐름을 잠깐 멈추고 운영체제나 특정 루틴을 실행하도록 만드는 메커니즘.
        
        명령어로도 호출되며(ex. `int 0x80`), 파일 읽기/쓰기, 키보드 입력 처리 같은 작업에 적용된다.
        
        하드웨어 인터럽트는 CPU 외부에서 일어나는 반면,
        
        소프트웨어 인터럽트는 실행되고 있는 프로그램이 의도적으로 CPU에게 인터럽트를 보내는 것이다.
        
        </aside>