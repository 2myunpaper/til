# 소스 코드와 명령어

컴퓨터는 명령어를 처리하는 기계라고 했다. 명령어는 컴퓨터를 실질적으로 작동 시키는 매우 중요한 정보이다.

그렇다면 C, C++, Java, Python과 같은 프로그래밍 언어로 만든 소스 코드는 무엇일까?

프로그래밍 언어로 만든 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환한다.

프로그래밍 언어가 어떻게 명령어가 되어 실행되는지 알아보자.

## 고급 언어와 저급 언어

컴퓨터는 C, C++, Java, Python과 같은 프로그래밍 언어를 이해할 수 있을까?

→ 이해할 수 없다. 우리가 프로그램을 만들 때 사용하는 프로그래밍 언어는 사람이 이해하고 작성하기 쉽게 만들어진 언어이다.

이러한 ‘사람을 위한 언어’ 를 **고급 언어**라고 한다. 대부분의 프로그래밍 언어가 이에 속한다.

반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 **저급 언어**라고 한다.

즉, 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 **명령어로 변환되어야 한다**!

저급 언어에는 **기계어**, **어셈블리어**가 존재한다.

<aside>

**기계어 (machine code)**

0과 1의 명령어 (이진수) 비트로 이루어진 언어.

이진수로 나열하면 너무 길어지기 때문에 가독성을 위해 십육진수로 표현하기도 한다.

</aside>

그러나 기계어만 보고는 컴퓨터가 어떻게 작동시키는지 감이 잡히지 않을 것이다. 기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 읽으면 이해하기 어렵다.

→ 이것을 해결할 저급 언어가 **어셈블리어**이다.

<aside>

**어셈블리어 (assembly language)**

기계어를 읽기 편한 형태로 번역한 언어.

*ex)*

| **기계어** | **어셈블리어** |
| --- | --- |
| 0101 0101 | push rbp |
| 0101 1101 | pop rbp |
| 1100 0011 | ret |
</aside>

어셈블리어는 한 줄 한 줄이 명령어로 이루어져 있다.

개발자가 어셈블리어를 이용해 복잡한 프로그램을 만드는 것은 쉽지 않다.

→ 그래서 고급 언어가 필요하고, 고급 언어는 더 나은 가독성, 변수, 함수와 같이 편리한 문법을 제공하기 때문에 복잡한 프로그램 구현이 가능하다.

**그러면 왜 저급 언어를 알아야 할까?**

→ 하드웨어와 밀접하게 맞닿아 있는 프로그램(임베디드, 게임, 정보 보안 분야 등)을 개발한다면 어셈블리어를 이용해 프로그램을 작성하기도 한다.

→ 또한, 이들에게는 어셈블리어가 관찰의 대상이 되며, 컴퓨터가 어떤 과정으로 실행되는지, 어떤 절차로 작동하는지를 근본적인 단계부터 추적하고 관찰할 수 있게 된다.

그러므로, 어떤 개발자가 되길 희망하는 지에 따라 저급 언어의 중요성이 달라질 것이다.

특히 프로그래밍을 시작한 입문자라면 반드시 알아두는 것이 좋다.

## 컴파일 언어와 인터프리터 언어

개발자들이 고급 언어로 작성한 코드는 결국 저급 언어로 변환되어 실행된다.

그럼 어떻게 변환될까?

→ 두 가지 방식으로 **컴파일 방식**, **인터프리트 방식**이 있다.

→ 각각의 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**, **인터프리 언어**라고 한다.

### 컴파일 언어

<aside>

**컴파일 언어**

컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어.

*ex)* C, C++

</aside>

<aside>

**컴파일 (compile)**

컴파일 언어로 작성된 소스 코드 전체를 저급 언어로 변환되는 과정.

**컴파일러 (compiler)**

컴파일을 수행해 주는 도구. 소스 코드 전체를 훑어보며 문법적 오류가 없는지, 실행 가능한 코드인지, 불필요한 코드는 없는지 등을 따지면서 컴파일한다.

</aside>

컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다.

컴파일러를 통해 저급 언어로 변환된 코드를 **목적 코드**라고 한다.

### 인터프리터 언어

<aside>

**인터프리터 언어**

인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어.

*ex)* Python

</aside>

<aside>

**인터프리터 (interpreter)**

소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구. 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다.

</aside>

컴파일 언어와 달리, 인터프리터 언어는 N번째 줄에 오류가 있다면, N-1번째 줄까지는 올바르게 수행된다.

이를 보면, 인터프리터 언어가 컴파일 언어보다 빠를 것 같지만, 일반적으로 인터프리터 언어가 더 느리다.

컴파일을 통해 나온 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 저급 언어로 해석하며 실행해야 하기 때문이다.

그런데, 모든 프로그래밍 언어들이 컴파일 언어와 인터프리터 언어로 확실히 구분되는 것일까? → 답은 아니다.

Java는 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행한다.

- ❓ **Java 언어의 특징**
    
    <aside>
    
    - **컴파일 언어적 관점**
        
        자바의 소스 코드는 Javac라는 컴파일러를 통해 **바이트코드**로 전환된다.
        
        바이트코드는 기계어가 아닌 중간 단계의 코드로, 특정 플랫폼에 종속되지 않는 것이 특징이다.
        
        컴파일 언어의 관점에서 보면 자바는 다음과 같은 특징을 갖는다.
        
        - 소스 코드를 바이트코드로 변환하여 저장한다.
        - 동일한 바이트코드를 다양한 운영 체제에서 사용할 수 있다.
        
        그러나, 바이트코드는 실행을 위해 **JVM(Java Virtual Machine)**이 필요하며, 곧바로 실행되는 것이 아니다. → Java는 컴파일 언어라고만 볼 수 없다.
        
    - **인터프리터 언어적 관점**
        
        JVM은 자바 바이트코드를 읽어 해석하고 실행하는 인터프리터의 역할을 수행한다.
        
        그러나 **JIT(Just-In-Time)** 컴파일러의 존재로 인해 단순한 인터프리터 언어로 보기 어렵다.
        
        JVM은 실행 중에 자주 사용되는 바이트코드를 기계어로 변환한다. → 이렇게 하면 실행 속도가 빨라진다. 최적화 작업
        
    - **결론**
        
        컴파필 언어와 인터프리터 언어의 장점을 결합한 혼합형 언어이다.
        
        Python에도 JIT 컴파일러를 활용해 PyPy에서 성능을 향상시키기도 했다.
        
    </aside>
    

참고로, Python도 컴파일을 하지 않는 것은 아니다.

즉, 프로그래밍 언어가 반드시 둘 중 하나의 방식만으로 작동하는 것이 아니다.

→ *“고급 언어가 저급 언어로 변환되는 대표적인 방법에는 크게 2가지가 있다.”* 로 이해하는 것이 적절하다.

정리하자면,

컴퓨터가 고급 언어를 컴파일 또는 인터프리트하여 저급 언어로 변환하는 것은,

외국어를 알지 못하는 사람에게 한꺼번에 번역 또는 한 줄씩 번역해서 알려주는 것과 비슷한 원리라고 이해할 수 있겠다.

*ex)* 한꺼번에 번역하는 것과 한 줄씩 번역하는 것의 차이를 생각해보자.

한꺼번에 번역해서 알려주기 = 컴파일

→ 컴파일은 번역하는 시간은 걸림. 건네주는 시간은 짧음.

→ 빠르게 읽을 수 있을 것임.

한 줄씩 번역해서 알려주기 = 인터프리트

→ 시간이 비교적 많이 듦.

### 참고: 목적 파일 vs 실행 파일

컴파일러를 통해 만들어진 저급 언어를 목적 코드라 부른다고 했다.

목적 코드로 이루어진 파일은 목적 파일, 실행 코드로 이루어진 파일은 실행 파일이라고 부른다.

**그렇다면 이 둘은 같은 의미일까? → 그렇지 않다.**

목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거친다.

링킹에 대해 알아보기 위해 아래 예시를 확인해보자.

1. 컴파일 언어로 `helper.c` 와 `main.c` 라는 소스 코드를 작성했다.
2. `helper.c` 안에는 ‘HELPER_더하기’ 라는 기능이 구현되어 있다.
    
    `main.c` 는 `helper.c` 에 구현된 ‘HELPER_더하기’ 기능과 프로그래밍 언어가 기본으로 제공하는 ‘화면_출력’ 이라는 기능을 가져다 사용한다.
    
3. 이들을 컴파일하여 `helper.o` , `main.o` 라는 목적 파일이 생성되었다.
4. `main.o` 는 외부의 기능을 가져다 사용한다는 내용이 저급 언어로 만들어진 것이라 바로 실행할 수 없다.
5. 따라서 `main.o` 가 실행되면, 외부 기능들(’HELPER_더하기’, ‘화면_출력’)과 연결 짓는 작업이 필요하다. → 이러한 작업을 **링킹(linking)** 이라고 한다.

따라서 **링킹** 작업까지 거쳐야, 목적 코드가 실행 파일으로 만들어질 수 있는 것이다.

# 명령어의 구조

연산 코드, 오퍼랜드, 주소 지정 방식에 대해 알아보자.

## 연산 코드와 오퍼랜드

컴퓨터 속 명령어도 사람과 같이,

“무엇을 대상으로, 어떤 작동을 수행해라”

라는 구조로 되어 있다.

| **연산 코드 필드** | **오퍼랜드 필드1** | **오퍼랜드 필드2** | **오퍼랜드 필드 n** |
| --- | --- | --- | --- |
| **작동 (연산)** | **사용할 데이터 1** | **사용할 데이터 2** | … |
| 더해라 | 100 | 120 | … |
| 빼라 | 메모리 32번지 안의 값 | 메모리 33번지 안의 값 | … |
| … | … | … | … |

명령어는 **연산 코드**와 **오퍼랜드**로 구성되어 있다.

<aside>

**연산 코드 (operation code) = 연산자**

명령어가 수행할 연산.

</aside>

<aside>

**오퍼랜드 (operand) = 피연산자**

연산에 사용할 데이터가 저장된 위치 또는 연산에 사용할 데이터.

</aside>

**기계어와 어셈블리어** 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.

### 오퍼랜드

숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.

많은 경우 연산에 사용할 데이터가 저장된 위치(메모리 주소, 레지스터 이름)이 담긴다. → 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.

오퍼랜드는 명령어 안에 하나도 없을 수도, 한 개만 있을 수도, 여러 개 있을 수도 있다.

```nasm
	mov  eax, 0
	pop  rbp
	ret
```

- ❓ **어셈블리어 연산 코드 지식 (위에 있는 것만!)**
    
    <aside>
    
    `mov` : 레지스터에 값을 할당하는 코드
    
    `ret` : 스택에서 Return Address를 POP 하여 EIP 레지스터에 저장한다
    
    ※  EIP는 Instruction Pointer로 CPU가 처리할 명령어의 주소를 나타내는 레지스터
    
    ※ 명령어는 Stack 형식으로 저장된다.
    
    </aside>
    
- ❓ **어셈블리어 문법**
    
    <aside>
    
    [[Assembly] 어셈블리어 기초 사용법 & 예제 총정리](https://coding-factory.tistory.com/651)
    
    *~~레지스터에 대해서는 4장 이후부터 자세히 배울 것 같으니 딥하게 보진 않겠습니다… ㅎ~~*
    
    단, CPU마다 어셈블리어 문법이 다르다는 점은 알아가면 좋을 것 같다.
    
    |  | Intel | AT&T |
    | --- | --- | --- |
    | 연산 과정 | Operand2에 Operand1을 연산함. | Operand1에 Operand2을 연산함. |
    | 숫자 표현 | 1, 2, 3, 4, 5… | $1, $2, $3, $4, $5… |
    | 레지스터 표현 | EAX, EBX, EBP… | %EAX, %EBX, %EBP… |
    </aside>
    

오퍼랜드가 하나도 없는 명령어를 **0-주소 명령어,**

오퍼랜드가 하나인 명령어를 **1-주소 명령어,**

두 개인 명령어를 **2-주소 명령어,**

세 개인 명령어를 **3-주소 명령어** 라고 한다.

### 연산 코드

크게 네 가지로 나눌 수 있다.

1. **데이터 전송**
2. **산술/논리 연산**
3. **제어 흐름 변경**
4. **입출력 제어**

참고로, 명령어의 종류와 생김새는 CPU마다 다르기 때문에 연산 코드의 종류와 생김새 또한 CPU마다 다르다.

아래에 나오는 내용은 대부분의 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류이다.

<aside>

1. **데이터 전송**
    
    `MOVE` : 데이터를 옮겨라
    
    `STORE` : 메모리에 저장하라
    
    `LOAD(FETCH)` : 메모리에서 CPU로 데이터를 가져와라
    
    `PUSH` : 스택에 데이터를 저장하라
    
    `POP` : 스택의 최상단 데이터를 가져와라
    
</aside>

<aside>

1. **산술/논리 연산**
    
    `ADD / SUBTRACT / MULTIPLY / DIVIDE` : 덧셈 / 뺄셈 / 곱셈 / 나눗셈
    
    `INCREMENT / DECREMENT`  : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
    
    `AND / OR / NOT` : `AND / OR / NOT` 연산을 수행하라
    
    `COMPARE` : 두 개의 숫자 또는 `TRUE / FALSE` 값을 비교하라
    
</aside>

<aside>

1. **제어 흐름 변경**
    
    `JUMP` : 특정 주소로 실행 순서를 옮겨라
    
    `CONDITIONAL JUMP` : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    
    `HALT` : 프로그램의 실행을 멈춰라
    
    `CALL` : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    
    `RETURN` : `CALL`을 호출할 때 저장했던 주소로 돌아가라
    
</aside>

`CALL` 은 함수 호출, `RETURN` 은 리턴하는 명령어로 이해하면 된다. 

<aside>

1. **입출력 제어**
    
    `READ(INPUT)` : 특정 입출력 장치로부터 데이터를 읽어라
    
    `WRITE(OUTPUT)` : 특정 입출력 장치로 데이터를 써라
    
    `START IO` : 입출력 장치를 시작하라
    
    `TEST IO` : 입출력 장치의 상태를 확인하라
    
</aside>

- **❓ 명령어 연산 코드 종류**
    
    <aside>
    
    [명령어의 연산 종류](https://blog.naver.com/hmk1998/223559848071)
    
    여기에서 주의 깊게 본 부분은, 제어 흐름 변경(제어, 이동) 부분이다.
    
    컴퓨터는 명령어를 순서대로 받는데, 특정한 경우(반복 필요, 조건문이 필요한 경우, 이전에 작업하던 경로로 넘어가기 등)가 발생할 시 흐름 제어 및 이동이 필요하다.
    
    이를 해결하는 제일 일반적이 3가지 방법은
    
    **분기(branch), 건너뜀(skip), 프로시저 호출(procedure call)** 이다.
    
    </aside>
    

## 주소 지정 방식

**왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 것일까?**

→ 명령어의 길이 때문이다.

하나의 명령어가 n비트로 구성되어 있고, 그 중 연산 코드 필드가 m비트라고 가정해보자. 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 n-m 비트가 된다.

오퍼랜드 필드 개수가 늘어날 수록, 필드의 길이는 더욱 작아질 것이다.

*ex1) 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어*

(16-4) / 2 = 6 → 오퍼랜드 필드로 표현할 수 있는 정보의 개수는  2^6개

*ex2) 명령어의 크기가 16비트, 연산코드 필드가 4비트인 3-주소 명령어*

(16-4) / 3 = 4 → 오퍼랜드 필드로 표현할 수 있는 정보의 개수는 2^4개

이러한 오퍼랜드 필드 안에 **메모리 주소가 담긴다면**, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

(레지스터 이름을 명시할 때도 마찬가지이다.)

*ex)*

*한 주소에 16비트를 저장할 수 있는 메모리가 주어짐.*

*명령어의 크기가 16비트, 연산 코드가 4비트인 3-주소 명령어*

오퍼랜드 필드는 메모리 주소를 가리켜 표현할 수 있는 정보의 개수는 2^16개

연산 코드에 사용할 데이터가 저장된 위치를 **유효 주소(effective address)**라고 한다.

오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때, 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식(addressing mode)**라고 한다.

→ 즉, 주소 지정 방식은 유효 주소를 찾는 방법이다!

대표적인 주소 지정 방식 다섯 가지를 알아보자.

<aside>

### 즉시 주소 지정 방식 (Immediate addressing mode)

오퍼랜드 필드에 **연산에 사용할 데이터**를 직접 명시하는 방식.

가장 간단한 형태이지만, 표현할 수 있는 데이터의 크기가 작아지는 단점 있음.

메모리나 레지스터로부터 찾는 과정이 없기 때문에 가장 빠르게 작동한다.

</aside>

<aside>

### 직접 주소 지정 방식 (direct addressing mode)

오퍼랜드 필드에 **유효 주소를 직접적**으로 명시하는 방식.

여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듦.

→ 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

</aside>

<aside>

### 간접 주소 지정 방식 (indirect addressing mode)

오퍼랜드 필드에 **유효 주소의 주소**를 명시하는 방식.

→ 메모리에 유효 주소가 존재하여, 그 주소를 오퍼랜드 필드에 명시하는 것.

표현할 수 있는 유효 주소의 범위가 넓어짐.

그러나, 두 번의 메모리 접근이 필요하여 일반적으로 느린 방식.

</aside>

<aside>

### 레지스터 주소 지정 방식 (register addressing mode)

때때로 연산에 사용할 데이터가 레지스터에 저장된 경우가 있다.

직접 주소 지정 방식과 비슷하게 **연산에 사용할 데이터를 저장한 레지스터 이름**을 오퍼랜드 필드에 직접 명시하는 방식.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. → 직접 주소 지정 방식보다 빠르다.

그러나, 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

</aside>

<aside>

### 레지스터 간접 주소 지정 방식 (register indirect addressing mode)

**연산에 사용할 데이터를 메모리에 저장**하고, **그 유효 주소를 저장한 레지스터**를 오퍼랜드 필드에 명시하는 방식.

간접 주소 지정 방식과 달리, 메모리에 접근하는 횟수가 한 번으로 줄어듦. → 간접 주소 지정 방식보다 빠르다.

</aside>

이 밖에 레지스터에 대해 더 공부해야만 이해할 수 있는 주소 지정 방식들이 있다. 4장에서 배울 예정이다.

### 참고: 스택과 큐

대표적인 데이터 관리 방식

<aside>

**스택 (Stack)**

후입선출, LIFO (Last In First Out)

새로운 데이터를 저장하는 명령어를 `PUSH` ,

스택에 저장된 데이터를 꺼내는 명령어를 `POP` .

</aside>

<aside>

**큐 (Queue)**

선입선출, FIFO (First In First Out)

</aside>